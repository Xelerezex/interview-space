# C++ interview questions:

## Table of Contents


|  No.  | Questions |
| :---: | :-------- |
|       | **[Препроцессор и компиляция](#препроцессор-и-компиляция)** |
|   1   | [Как проходит процесс компиляции срр-файлов в бинарный файл?](#как-проходит-процесс-компиляции-срр-файлов-в-бинарный-файл) |
|   2   | [Что такое препроцессор?](#что-такое-препроцессор) |
|   3   | [Как работает препроцессор?](#как-работает-препроцессор) |
|   4   | [Какие существуют команды препроцессора?](#какие-существуют-команды-препроцессора) |
|   5   | [Как работает директива include?](#как-работает-директива-include) |
|   6   | [Как работает директива define?](#как-работает-директива-define) |
|   7   | [Что именно линкует линкер?](#что-именно-линкует-линкер) |
|   8   | [Что такое оптимизация компилятора?](#что-такое-оптимизация-компилятора) |
|   9.  | [Что такое флаги компиляции?](#что-такое-флаги-компиляции) |
|   10. | [Как защитить хедер от повторного включения?](#как-защитить-хедер-от-повторного-включения) |
|   11. | [Расскажите о системах автоматизации билд-процесса](#расскажите-о-системах-автоматизации-билд-процесса) |
|   12. | [Какая разница между статической и динамической библиотеками?](#какая-разница-между-статической-и-динамической-библиотеками) |
|   13. | [Что такое DLL hell?](#что-такое-dll-hell) |
|   14. | [Что такое флаг компиляции -fPIC?](#что-такое-флаг-компиляции--fpic) |
|   15. | [В чем разница между дебаженной и релизной сборкой?](#в-чем-разница-между-дебаженной-и-релизной-сборкой) |
|   16. | [Что такое internal linkage?](#что-такое-internal-linkage) |
|   17. | [Что такое барьеры памяти?](#что-такое-барьеры-памяти) |
|       | **[C](#c)** |
|   18. | [В каких случаях используется ключевое слово static?](#в-каких-случаях-используется-ключевое-слово-static) |
|   19. | [Что означает ключевое слово const?](#что-означает-ключевое-слово-const) |
|   20. | [Что означает ключевое слово extern?](#что-означает-ключевое-слово-extern) |
|   21. | [Что означает ключевое слово volatile?](#что-означает-ключевое-слово-volatile) |
|   22. | [Какие есть битовые операции?](#какие-есть-битовые-операции) |
|   23. | [Где хранятся переменные в памяти?](#где-хранятся-переменные-в-памяти) |
|   24. | [Какая разница между calloc и malloc?](#какая-разница-между-calloc-и-malloc) |
|   25. | [Для чего используют realloc?](#для-чего-используют-realloc) |
|   26. | [Что такое указатель?](#что-такое-указатель) |
|   27. | [Каков размер указателя и от чего он зависит?](#каков-размер-указателя-и-от-чего-он-зависит) |
|   28. | [Какие есть операции с указателями?](#какие-есть-операции-с-указателями) |
|   29. | [Что такое struct?](#что-такое-struct) |
|   30. | [Как определить размер структур?](#как-определить-размер-структур) |
|   31. | [Что такое выравнивание в структурах?](#что-такое-выравнивание-в-структурах) |
|   32. | [Что такое union?](#что-такое-union) |
|   33. | [Какой размер union?](#какой-размер-union) |
|   34. | [Что будет, если дважды вызвать free?](#что-будет-если-дважды-вызвать-free) |
|   35. | [Как происходит вызов функции?](#как-происходит-вызов-функции) |

### Препроцессор и компиляция:

1. ### Как проходит процесс компиляции срр-файлов в бинарный файл?

Существует 5 стадий преобразования файла:

```
        Препроцессинг -> Компиляция -> Ассемблирование -> Компоновка -> Загрузка
```

-   **Препроцессинг** - все препроцессорные директивы (```#include```, ```#define```, ```#if```,
    ```#ifdef``` и ```#ifndef``` и т.д.) рекурсивно раскрываются и включаются в выпускаемый файл.
    Получается выходной файл с расширением **.ii**. С флагом ```-Е``` можно увидеть выходной файл
    после препроцесинга.

-   **Компиляция** - компилятор преобразует скомпанованный файл в ассемблерный код. Ассемблерный код
    — это доступное для понимания человеком представление машинного кода. Получается выходной файл с
    расширением **.s**. С флагом ```-S``` можно увидеть выходной файл после компиляции.

-   **Ассемблер** - Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в объектном
    файле с расширением **.o**. Объектный файл — это созданный ассемблером промежуточный файл, хранящий
    кусок машинного кода. Далее возможно сохранение данного объектного кода в статические библиотеки для
    того, чтобы не компилировать данный код снова.

-   **Компоновщик (линкер)** - вязывает все объектные файлы и статические библиотеки в единый исполняемый
    файл, который мы и сможем запустить в дальнейшем.

-   **Загрузка** - вызывается загрузчик для загрузки нашей программы в память. На данной стадии также
    возможна подгрузка динамических библиотек.

**[⬆ Back to Top](#table-of-contents)**

2. ### Что такое препроцессор?

**Препроцессор** — это компьютерная программа, принимающая данные на входе и выдающая данные,
предназначенные для входа другой программы (например, компилятора). О данных на выходе препроцессора
говорят, что они находятся в препроцессированной форме, пригодной для обработки последующими программами
(компилятором).


**[⬆ Back to Top](#table-of-contents)**

3. ### Как работает препроцессор?

Препроцессор предназначен для предварительной обработки текста программы. Препроцессор позволяет включать в
текст программы файлы и вводить макроопределения. Работа препроцессора осуществляется с помощью специальных
директив (указаний). Они отмечаются знаком решетка ```#```. По окончании строк, обозначающих директивы в
языке Си, точку с запятой можно не ставить.

**[⬆ Back to Top](#table-of-contents)**

4. ### Какие существуют команды препроцессора?

-   ```#include``` — вставляет текст из указанного файла.

-   ```#using``` — импортирует метаданные в программу.

-   ```#define``` — задаёт макроопределение (макрос) или символическую константу.

-   ```#undef``` — отменяет предыдущее определение.

-   ```#if``` — осуществляет условную компиляцию при истинности константного выражения.

-   ```#ifdef``` — осуществляет условную компиляцию при определённости символической константы.

-   ```#ifndef``` — осуществляет условную компиляцию при неопределённости символической константы.

-   ```#else``` — ветка условной компиляции при ложности выражения.

-   ```#elif``` — ветка условной компиляции, образуемая слиянием ```else``` и ```if```.

-   ```#endif``` — конец ветки условной компиляции.

-   ```#line``` — препроцессор изменяет номер текущей строки и имя компилируемого файла.

-   ```#error``` — выдача диагностического сообщения.

-   ```#pragma``` — действие, зависящее от конкретной реализации компилятора.

-   ```#import``` — используется для включения сведений из библиотеки типов.

**[⬆ Back to Top](#table-of-contents)**

5. ### Как работает директива include?

Директива ```#include``` включает полный текст системных файлов или файлов пользователя на то место, где
она стоит в коде.

Существует три модификации директивы ```#include```:

-   ```#include <FILE>``` — Эта модификация используется для подключения системных файлов. При ее
    выполнении производится поиск файла с именем ```FILE``` в списке указанных заранее каталогов,
    а затем в стандартном списке системных каталогов.

-   ```#include "FILE"``` — Эта модификация применяется для подключаемых файлов для программ пользователя.
    Сначала файл ```FILE``` просматривается в текущем каталоге, а затем в каталогах для системных
    подключаемых файлов.

-   ```#include ANYTHING ELSE``` — Эта модификация называется "вычисляемой директивой ```#include```".
    Строка ```ANYTHING ELSE``` проверяется на наличие соответствующего макроса, значение которого затем
    заменяет его название. Полученная в результате строка должна уже в точности соответствовать одной из
    рассмотренных выше модификаций(то есть имя подключаемого файла должно быть заключено в кавычки или
    угловые скобки).

**[⬆ Back to Top](#table-of-contents)**

6. ### Как работает директива define?

Директива ```#define``` позволяет вводить в текст программы константы и макроопределения.
Общая форма записи

```cpp
    #define ID REPLACEMENT
```

Поля ```ID``` и ```REPLACEMENT``` разделяются одним или несколькими пробелами.
Директива ```#define``` указывает компилятору, что нужно подставить строку, определенную аргументом
```REPLACEMENT```, вместо каждого аргумента ```ID``` в исходном файле. ```ID``` не заменяется, если он
находится в комментарии, в строке или как часть более длинного идентификатора.

**[⬆ Back to Top](#table-of-contents)**

7. ### Что именно линкует линкер?

**Линкер** — программа, которая производит компоновку («линковку»): принимает на вход один или
несколько объектных модулей и собирает из них исполняемый или библиотечный файл-модуль.
Кокретнее для ```С/С++```: где-то в коде будет объявление переменной или функции. Это значит
что где-то будет и определение. Задача линкера - соеденить объявление и определение функции,
переменных и т.д.

**[⬆ Back to Top](#table-of-contents)**

8. ### Что такое оптимизация компилятора?

**Оптимизация** — это процесс преобразования части кода в другую функционально эквивалентную часть для
улучшения одной или более характеристик кода. Две самые важные характеристики — это скорость работы и размер
кода. Как пример: достигается через флаги компиляции, на этапе компиляции программы.

**[⬆ Back to Top](#table-of-contents)**

9. ### Что такое флаги компиляции?

**Флаг компиляции** - это специальная настройка передаваемая компилятору во время препроцессирование,
компиляции, ассемблировании или при линковке.

**[⬆ Back to Top](#table-of-contents)**

10. ### Как защитить хедер от повторного включения?

В чистом ```С``` для этого нужно обернуть хедер следующим выражением:

```c
#ifndef H_HEADER
#define H_HEADER

// Header itself

#endif
```

В ```С++``` чаще применяется следующая деректива препроцессора в начале хедера:

```cpp
#pragma once
```

**[⬆ Back to Top](#table-of-contents)**

11. ### Расскажите о системах автоматизации билд-процесса.

**Автоматизация сборки** — этап процесса разработки программного обеспечения, заключающийся в автоматизации
широкого спектра задач, решаемых программистами в их повседневной деятельности.

Включает такие действия, как:

-   компиляция исходного кода в объектный модуль,

-   сборка бинарного кода в исполняемый файл,

-   выполнение тестов,

-   развёртывание программы в целевой среде,

-   написание сопроводительной документации или описание изменений новой версии.

Для автоматизации нужно написать специальный скрипт, в котором будут описаны все этапы сюорки программы.
Самый частый формат - ```Makefile```. Этот формат читает большинство инструментов для сборки, таких как:

-   Automake.

-   CMake.

-   qmake.

-   imake.

и т.д.

**[⬆ Back to Top](#table-of-contents)**

12. ### Какая разница между статической и динамической библиотеками?

**Статическая библиотека** - это архив объектных файлов, который используется в процессе статической линковки.
В результате статической линковки из многих объектных файлов получается один исполняемый, запускается
статическая линковка в момент создания исполняемого файла. Особенностью является то, что исполняемый файл
содержит полную копию кода библиотеки.

**Динамическая библиотека** - Динамическая линковка запускается в момент создания процесса (когда вы запускаете
исполняемый файл на выполнение), линкуются между собой несколько исполняемых файлов каждый раз, когда создается
новый процесс. Так же возможна динамическая линковка уже после запуска, т.е. новая библиотека может быть подгружена
в адресное пространство ужа работающего процесса. Особенностью является то, что динамическая библиотека содержит
код и данные, которые могут использоваться несколькими программами одновременно. DLL не является исполняемым.
файлом. Динамическое связывание позволяет процессу вызывать функции, не являющиеся частью его исполняемого кода.
Исполняемый код функции находится в DLL, которая содержит одну или несколько функций, которые были скомпилированы,
связаны и хранятся отдельно от процесса, который их использует.

**[⬆ Back to Top](#table-of-contents)**

13. ### Что такое DLL hell?

**DLL hell** - тупиковая ситуация, связанная с управлением динамическими библиотеками ```DLL``` в операционной
системе Microsoft Windows. Аналогичная проблема в других ОС носит название ```Dependency hell```.

Сущность проблемы заключается в конфликте версий ```DLL```, призванных поддерживать определённые функции.
```DLL hell``` — пример плохой концепции программирования, которая, подобно скрытой мине, приводит к
резкому возрастанию трудностей при усложнении и совершенствовании системы.

По исходному замыслу, ```DLL``` должны быть совместимыми от версии к версии и взаимозаменяемыми в обе стороны.

Реализация механизма ```DLL``` такова, что несовместимость и невзаимозаменяемость становится скорее правилом,
чем исключением, что приводит к большому количеству проблем.

-    Отсутствие стандартов на имена, версии и положение ```DLL``` в файловой структуре приводит к тому, что
     несовместимые ```DLL``` легко замещают или отключают друг друга.

-    Отсутствие стандарта на процедуру установки приводит к тому, что установка новых программ приводит к
     замещению работающих ```DLL``` на несовместимые версии.

-    Отсутствие поддержки ```DLL``` со стороны компоновщиков и механизмов защиты приводит к тому, что
     несовместимые ```DLL``` могут иметь одинаковые имя и версию.

-    Отсутствуют стандартные инструменты идентификации и управления системой ```DLL``` пользователями и
     администраторами.

-    Использование отдельных ```DLL``` для обеспечения связи между задачами приводит к нестабильности сложных
     приложений.

**[⬆ Back to Top](#table-of-contents)**

14. ### Что такое флаг компиляции -fPIC?

**Флаг -fPIC** - это компиляция позиционно-независимого кода. Только из таких кодов можно сделать
динамическую библиотеку с разделяемыми кодами. Если компилировать модули без -fPIC и потом собрать
*.so, то формально динамическая библиотека получится, но код будет не разделяемым. Для каждого
процесса, использующего этот модуль, будет создаваться копия кодов. Флаг -fPIC нужен для компиляции из
исходника в объектник, для линковки не нужен. "Нормальный" процесс выглядит так:

```commandline
gcc t1.c -c -fPIC
gcc t2.c -c -fPIC
gcc t3.c -c -fPIC
gcc -shared t1.o t2.o t2.o -o libqqq.so
```

**[⬆ Back to Top](#table-of-contents)**

15. ### В чем разница между дебаженной и релизной сборкой?

**Конфигурация сборки** — это набор настроек проекта, которые определяют принцип его построения. Конфигурация
сборки состоит из:

-   имени исполняемого файла;

-   имени директории исполняемого файла;

-   имён директорий, в которых IDE будет искать другой код и файлы библиотек;

-   информации об отладке и параметрах оптимизации вашего проекта.

**Конфигурация Debug** предназначена для отладки программы. Эта конфигурация отключает все настройки по
оптимизации, включает информацию об отладке, что делает программы больше и медленнее, но упрощает
проведение отладки. Режим ```Debug``` обычно используется в качестве конфигурации по умолчанию.

**Конфигурация Release** используется во время сборки программы для её дальнейшего выпуска. Программа
оптимизируется по размеру и производительности и не содержит дополнительную информацию об отладке.

**[⬆ Back to Top](#table-of-contents)**

16. ### Что такое internal linkage?

**Единица трансляции** — минимальный блок исходного текста, который физически можно оттранслировать
(преобразовать во внутреннее машинное представление; в частности, откомпилировать).
В языках программирования Си и Си++ единица трансляции — подаваемый на вход компилятора исходный текст
(файл с расширением ```.c``` или ```.cpp```) со всеми включёнными в него файлами.

**Internal linkage** — свойство объекта или функции. Если объект или функция имеют ```internal linkage```
то эта самая функция или объект видны линкеру только внутри своей еденицы трансляции. За это отвечает
ключевое слово ```static```.

**External linkage** — так же свойство объекта или функции, но он оповещает линкер, что объект или функция
должны быть видны вне своей еденицы трансляции. За это отвечает ключевое слово ```extern```.

Дефолтные настройки компилятора в плане связки (linkage):

-   Неконстантные глобальные переменные имеют  ```external linkage```.

-   Константные глобальные переменные имеют  ```Internal linkage```.

-   Функции имеют ```external linkage``` изначально.


**[⬆ Back to Top](#table-of-contents)**

17. ### Что такое барьеры памяти?

**Барьер памяти** — вид барьерной инструкции, которая приказывает компилятору (при генерации инструкций) и
центральному процессору (при исполнении инструкций) устанавливать строгую последовательность между
обращениями к памяти (переменные в этой памяти и т.д.) до и после барьера. Это означает, что все обращения
к памяти перед барьером будут гарантированно выполнены до первого обращения к памяти после барьера.

Барьеры памяти работают только на аппаратном уровне. Компиляторы могут также переупорядочить инструкции как
часть оптимизации программы. Меры по предотвращению переупорядочивания необходимы только для данных, которые
не защищены примитивами синхронизации.

В языках ```С``` и ```С++``` ключевое слово ```volatile``` предназначено для исключения оптимизаций
компилятора. Используется чаще всего для работы с отображаемым в память вводом-выводом. Однако данное
ключевое слово никак не обеспечивает атомарность и защиту от внеочередного исполнения.

**[⬆ Back to Top](#table-of-contents)**

### C


18. ### В каких случаях используется ключевое слово ```static```?

в языке Си используется
в трёх случаях:

-   Переменная, описанная внутри тела функции как статическая, сохраняет свое значение между
    вызовами функции.

-   Переменная, описанная как статическая внутри модуля, но снаружи тела функции, доступна для
    всех функций в пределах этого модуля и не доступна функциям любых других модулей. То есть,
    это локализованная глобальная переменная.

-   Статический объект класса, создается на старте и уничтожается при завершении программы, и
    инициализируется только один раз. Инициализация объекта происходит, как и обычно — через
    конструктор класса.

-   Статическое поле класса, будет одним для всех экземпляров этого класса.

-   Статические методы класса, можно использовать без создания объекта класса. Доступ к статическим
    функциям осуществляется с использованием имени класса и *оператора разрешения области видимости (::)*
    Внутри функции обращаться можно только к статическим членам данных, другим статическим функциям-членам
    и любым другим функциям извне класса. Статические функции-члены имеют область видимости класса, в
    котором они находятся. Вы не имеете доступа к указателю ```this``` класса, потому что мы не создаем
    никакого объекта для вызова этой функции.

-   Функции, описанные внутри модуля как статические, могут быть вызваны только другими функциями
    из этого модуля. То есть, область видимости функции локализована модулем, внутри которого она
    описана.


**[⬆ Back to Top](#table-of-contents)**

19. ### Что означает ключевое слово ```const```?

```const``` означает - «только для чтения».

Что означают следующие объявления?

```cpp
const int a;

int const a;

const int *a;

int * const a;

const int * const a;
```

-   Первые два объявления означают одну и ту же вещь, а именно: «а» - это целочисленная
    константа (только для чтения).

-   Третье означает, что «а» является указателем на целочисленную константу.

-   Четвёртое описывает «а» как константный указатель на целое.

-   И последнее объявление — константный указатель на целочисленную константу.

Важность ```const```:

-   Использование спецификатора ```const``` сообщает полезную информацию тому, кто читает код.
    Фактически, объявление параметра как ```const```, говорит пользователю о его предполагаемом
    использовании.

-   ```сonst``` сообщает оптимизатору некоторую дополнительную информацию, что потенциально
    позволяет генерировать более оптимальный код.

-   Код, в котором используется спецификатор ```const```, проявляет тенденцию к меньшему количеству
    ошибок.

**[⬆ Back to Top](#table-of-contents)**

20. ### Что означает ключевое слово ```extern```?

В дополнение к области видимости и продолжительности жизни, переменные имеют еще одно свойство —
связь. Связь переменной определяет, относятся ли несколько упоминаний одного идентификатора к одной и
той же переменной или нет.

Переменная без связей — это переменная с локальной областью видимости, которая относится только к блоку,
в котором она определена. Это обычные локальные переменные. Две переменные с одинаковыми именами, но
определенные в разных функциях, не имеют никакой связи — каждая из них считается независимой единицей.

Переменная, имеющая внутренние связи, называется внутренней переменной (или «статической переменной»).
Она может использоваться в любом месте файла, в котором определена, но не относится к чему-либо вне этого
файла.

Переменная, имеющая внешние связи, называется внешней переменной. Она может использоваться как в файле, в
котором определена, так и в других файлах.

Если вы хотите сделать глобальную переменную внешней (которую можно использовать в любом файле программы)
— используйте ключевое слово ```extern```.

**[⬆ Back to Top](#table-of-contents)**

21. ### Что означает ключевое слово ```volatile```?

Ключевое слово ```volatile``` информирует компилятор о том, что переменная может быть изменена не только из
текущего выполняемого кода, но и из других мест. Тогда компилятор будет избегать определенных оптимизаций этой
переменной.

Примеры ```volatile``` переменных:

-   Регистры в периферийных устройствах (например, регистры состояния)

-   Глобальные переменные, используемые в обработчиках прерываний.

-   Глобальные переменные, используемые совместно несколькими задачами в многопотоковом приложении.

**[⬆ Back to Top](#table-of-contents)**

22. ### Какие есть битовые операции?

В языке С++ есть 6 побитовых операторов:

|Оператор | Символ | Пример | Операция |
|  :---:  | :----: | :----: | :------: |
| Побитовый сдвиг влево | ```<<``` | ```x << y``` | Все биты в ```x``` смещаются влево на ```y``` бит |
| Побитовый сдвиг вправо | ```>>``` | ```x >> y``` | Все биты в ```x``` смещаются вправо на ```y``` бит |
| Побитовое НЕ | ```~``` | ```~x``` | Все биты в ```x``` меняются на противоположные |
| Побитовое И | ```&``` | ```x & y``` | Каждый бит в ```x``` И каждый соответствующий ему бит в ```y``` |
| Побитовое ИЛИ | ```|``` | ```x | y``` | Каждый бит в ```x``` ИЛИ каждый соответствующий ему бит в ```y``` |
| Побитовое исключающее ИЛИ (XOR)| ```^``` | ```x ^ y```| Каждый бит в ```x``` XOR с каждым соответствующим ему битом в ```y``` |

**[⬆ Back to Top](#table-of-contents)**

23. ### Где хранятся переменные в памяти?

Переменные сохраняются:

-    в стеке, если они ```automatic function-local variables```

-    в куче, если они выделены с помощью ```new``` или ```malloc``` и т.д.

-    в области данных каждого процесса, если они глобальны или ```static```.

Все это хранится в ОЗУ. Компиляторы могут оптимизировать код для хранения переменных в регистрах,
но это не желательно.

**[⬆ Back to Top](#table-of-contents)**

24. ### Какая разница между ```calloc``` и ```malloc```?

Функция ```malloc(num)``` определена в заголовочном файле **stdlib.h**, она используется для инициализации
указателей необходимым объемом памяти. Память выделяется из сектора оперативной памяти доступного для
любых программ, выполняемых на данной машине. Аргументом функции ```malloc(num)``` является количество байт
памяти, которую необходимо выделить, возвращает функция — указатель на выделенный блок в памяти.

Функция ```calloc(num)``` аналогична ```malloc(num)``` и выделяет блок памяти для массива размером —
```num``` элементов, каждый из которых занимает ```size``` байт, и инициализирует все свои биты в нулями.

**[⬆ Back to Top](#table-of-contents)**

25. ### Для чего используют ```realloc```?

Функция ```void * realloc( void * ptrmem, size_t size );``` выполняет перераспределение блоков памяти.
Размер блока памяти, на который ссылается параметр ```ptrmem``` изменяется на ```size``` байтов. Блок
памяти может уменьшаться или увеличиваться в размере.

Эта функция может перемещать блок памяти на новое место, в этом случае функция возвращает указатель на новое
место в памяти. Содержание блока памяти сохраняется даже если новый блок имеет меньший размер, чем старый.
Отбрасываются только те данные, которые не вместились в новый блок. Если новое значение ```size```  больше
старого, то содержимое вновь выделенной памяти будет неопределенным.

В случае, если ```ptrmem``` равен ```NULL```, функция ведет себя именно так, как функция ```malloc```, т. е.
выделяет память и возвращает указатель на этот участок памяти.

В случае, если ```size``` равен ```0```, ранее выделенная память будет освобождена, как если бы была вызвана
функция ```free```, и возвращается нулевой указатель.

-   ```ptrmem```. Указатель на блок ранее выделенной памяти функциями ```malloc```, ```calloc``` или
    ```realloc``` для перемещения в новое место. Если этот параметр — ```NULL```, просто выделяется новый
    блок, и функция возвращает на него указатель.

-   ```size```. Новый размер, в байтах, выделяемого блока памяти. Если ```size``` равно ```0```, ранее
    выделенная память освобождается и функция возвращает нулевой указатель, ```ptrmem``` устанавливается
    в ```0```.

**[⬆ Back to Top](#table-of-contents)**

26. ### Что такое указатель?

Указатели представляют собой объекты, значением которых служат адреса других объектов (переменных,
констант, указателей) или функций. Как и ссылки, указатели применяются для косвенного доступа к объекту.
Однако в отличие от ссылок указатели обладают большими возможностями.

Для определения указателя надо указать тип объекта, на который указывает указатель, и символ звездочки ```*```.
Например, определим указатель на объект типа ```int```:

```cpp
int *p;
```

Пока указатель не ссылается ни на какой объект. При этом в отличие от ссылки указатель необязательно
инициализировать каким-либо значением. Теперь присвоим указателю адрес переменной:

```cpp
int x = 10;     // определяем переменную
int *p;         // определяем указатель
p = &x;         // указатель получает адрес переменной
```

Для получения адреса переменной применяется операция ```&```. Что важно, переменная ```x``` имеет тип
```int```, и указатель, который указывает на ее адрес, тоже имеет тип ```int```. То есть должно быть
соответствие по типу.

**[⬆ Back to Top](#table-of-contents)**

27. ### Каков размер указателя и от чего он зависит?

В соответствии со стандартом C++, размер указателя зависит от конкретной реализации компилятора и не связан
напрямую с разрядностью используемой платформы. В рамках же конкретной реализации стандарта, размер
указателей различных типов (указатели на объекты, указатели на функции и т.п.) также может быть различным.

Однако на большинстве современных ОС общего назначения (настольные UNIX совместимые системы, MS Windows)
используются модели данных, в которых размер указателя соответствует разрядности адресной шины у архитектуры
этих платформ. Ширина шины адреса определяет объём адресуемой памяти. Например, если ширина адресной шины
составляет 32 бит, и размер слова памяти равен одному байту (минимальный адресуемый объём данных), то объём
памяти, который можно адресовать, составляет 2^32 байт, что и определяет оптимальный размер указателя для
такой платформы.

Так же язык ```С``` требует чтобы внутренние представления и требования выравнивания указателей совпадали
в следующих группах (в каждой группе - между собой)

-    Указатели void * и char *

-    Указатели на все struct-типы

-    Указатели на все union-типы

-    Указатели на совместимые типы

Во всех остальных случаях указатели могут иметь совершенно разное представление, в т.ч. отличающиеся размеры.

Т.е. да, формально указатели ```char *``` и ```int *``` могут иметь разный размер.

Причины, по которым может иметь смысл делать указатели разного размера включают

-    Разница в размере областей адресного пространства, в котором могут располагаться указуемые сущности.
     Например, как вы заметили, разница в размере областей кода и данных может обуславливать разницу в
     размерах указателей на данные и указателей на функции

-    Разница в требованиях выравнивания типа. Например, если некоторый экзотический тип требует выравнивания
     на границу 256 байт, то ему фактически "не нужен" последний байт в полном указателе.

**[⬆ Back to Top](#table-of-contents)**

28. ### Какие есть операции с указателями?

Указатели поддерживают ряд операций: присваивание, получение адреса указателя, получение значения по
указателю, некоторые арифметические операции и операции сравнения.

**Присваивание**

Указателю можно присвоить либо адрес объекта того же типа, либо значение другого указателя.

```cpp
int a = 10;
int *pa = &a;   // указатель pa хранит адрес переменной a
int *pb = pa;
```

**Нулевые указатели**

Нулевой указатель (null pointer) - это указатель, который не указывает ни на какой объект. Если мы не хотим,
чтобы указатель указывал на какой-то конкретный адрес, то можно присвоить ему условное нулевое значение.
Для создания нулевого указателя можно применять различные способы:

```cpp
int *p1 = nullptr;
int *p2 = NULL;
int *p3 = 0;
```

**Ссылки на указатели**

Так как ссылка не является объектом, то нельзя определить указатель на ссылку, однако можно определить
ссылку на указатель. Через подобную ссылку можно изменять значение, на которое указывает указатель или
изменять адрес самого указателя:

```cpp
int a = 10;

int *p = 0;         // указатель
int *&pRef = p;     // ссылка на указатель
pRef = &a;          // через ссылку указателю p присваивается адрес переменной a
```

**Разыменование указателя**

Операция разыменования указателя представляет выражение в виде ```*имя_указателя```. Эта операция позволяет
получить объект по адресу, который хранится в указателе.

```cpp
int a = 10;

int *pa = &a;
int *pb = pa;

*pa = 25;       // a == 25
```

**Адрес указателя**

Указатель хранит адрес переменной, и по этому адресу мы можем получить значение этой переменной. Но кроме
того, указатель, как и любая переменная, сам имеет адрес, по которому он располагается в памяти. Этот
адрес можно получить также через операцию ```&```:

**Операции сравнения**

К указателям могут применяться операции сравнения ```>```, ```>=```, ```<```, ```<=```, ```==```, ```!=```.
Операции сравнения применяются только к **указателям одного типа** и к значениям ```NULL``` и ```nullptr```.
Для сравнения используются номера адресов:

```cpp
int a = 10;
int b = 20;
int *pa = &a;
int *pb = &b;

if(pa > pb)
    cout << "pa (" << pa << ") is greater than pb ("<< pb << ")" << endl;
else
    cout << "pa (" << pa << ") is less or equal pb ("<< pb << ")" << endl;
```

```commandline
pa (0x60fe94) is greater than pb (0x60fe90)
```

**Приведение типов**

Иногда требуется присвоить указателю одного типа значение указателя другого типа. В этом случае следует
выполнить операцию приведения типов с помощью операции ```(тип_указателя *)```:

```cpp
char c = 'N';
char *pc = &c;
int *pd = (int *)pc;
void *pv = (void*)pc;
```

**[⬆ Back to Top](#table-of-contents)**

29. ### Что такое struct?

```struct``` - ключевое слово, которое позволяет пользователю создать свой собственный тип данных.

```cpp
struct Employee
{
    short id;
    int age;
    double salary;
};
```

Сейчас определена структура с именем ```Employee```. Она содержит 3 переменные:

-   ```id``` типа ```short```;

-   ```age``` типа ```int```;

-   ```salary``` типа ```double```.

Эти переменные, которые являются частью структуры, называются членами структуры (или «полями структуры»).
```Employee``` — это простое объявление структуры. Компилятору указано, что структура имеет переменные-члены
но, память под нее сейчас не выделяется. Имена структур принято писать с заглавной буквы, чтобы отличать их
от имен переменных.

**[⬆ Back to Top](#table-of-contents)**

30. ### Как определить размер структур?

Как правило, размер структуры — это сумма размеров всех её членов, но не всегда. Например, рассмотрим
структуру ```Employee```. На большинстве платформ тип ```short``` занимает ```2``` байта, тип ```int```
— ```4``` байта, а тип ```double``` — ```8``` байт. Следовательно, ожидается, что ```Employee``` будет
занимать ```2 + 4 + 8 = 14``` байт. Чтобы узнать точный размер ```Employee```, мы можем воспользоваться
оператором ```sizeof```:

```cpp
struct Employee
{
    short id;
    int age;
    double salary;
};


std::cout << "The size of Employee is " << sizeof(Employee) << "\n";
```

Результат выполнения программы:

```commandline
The size of Employee is 16
```

Оказывается, размер структуры будет, **по крайней мере**, **не меньше** суммы размеров всех её членов.
Но он может быть и больше. По соображениям производительности компилятор иногда может добавлять
«пробелы/промежутки» в структуры.

В структуре ```Employee``` компилятор неявно добавил ```2``` байта после члена ```id```, увеличивая размер
структуры до ```16``` байтов вместо ```14```.

**[⬆ Back to Top](#table-of-contents)**

31. ### Что такое выравнивание в структурах?

Элементы структуры данных хранятся последовательно в памяти, так что в приведенной ниже структуре данные
элемента ```Data1``` всегда будут предшествовать ```Data2```, а ```Data2``` всегда будут предшествовать
```Data3```:

```cpp
struct MyData
{
    short Data1;
    short Data2;
    short Data3;
};
```

Если тип ```short``` хранится в двух байтах памяти, то каждый элемент структуры данных, изображенной выше,
будет выровнен по ```2``` байта. ```Data1``` будут находиться со смещением ```0```, ```Data2``` - со
смещением ```2```, а Data3 - со смещением ```4```. Размер этой структуры будет составлять ```6``` байт.

Тип каждого элемента структуры обычно имеет выравнивание по умолчанию, что означает, что он будет,
если программист не запросит иного, выровнен по заранее определенной границе. Следующие типичные
выравнивания допустимы для компиляторов от Microsoft (Visual C++), Borland/CodeGear (C++Builder),
Digital Mars (DMC) и GNU (GCC) при компиляции для 32-разрядных x86:

| Тип            | Вес в байтах   | Выравнивание   |
| :------------: | :------------: | :------------: |
| ```char```     | 1 байт | будет выровнен на ```1``` байт. |
| ```short``` |  2 байта | будет выровнен на ```2``` байта. |
| ```int``` |    4 байта | будет выровнен на ```4``` байта. |
| ```long``` |   4 байта | будет выровнен на ```4``` байта. |
| ```float``` |  4 байта | будет выровнен на ```4``` байта. |
| ```double``` | 8 байт | будет выровнен на ```8``` байт в Windows и будет выровнен на ```4``` байта в Linux (8 байт с флагом компиляции-malign-double). |
| ```long long``` | 8 байт | будет выровнен на ```4``` байта. |
| ```long double``` | (10 байтов с C++Builder и DMC, 8 байт с Visual C++, 12 байт с GCC) |  будет выровнен на ```8``` байт с C++Builder,  будет выровнен на ```2``` байт с DMC,  будет выровнен на ```8``` байт с Visual C++, и  будет выровнен на ```4``` байта с GCC. |
| ```Any pointer``` | 4 байта |  будет выровнен на ```4``` байта (напр.: ```char*```, ```int*```) |

Единственными заметными различиями в выравнивании для 64-разрядной системы LP64 по сравнению с 32-разрядной системой являются:

| Тип            | Вес в байтах   | Выравнивание   |
| :------------: | :------------: | :------------: |
| ```long``` | 8 байт | будет выровнен на ```8``` байт |
| ```double``` | 8 байт | будет выровнен на ```8``` байт |
| ```long long```| 8 байт | будет выровнен на ```8``` байт |
| ```long double``` |  8 байт c Visual C++, 16 байт c GCC | будет выровнен на ```8``` байт c Visual C++ и будет выровнен на ```16``` байт с GCC. |
| ```Any pointer``` | 8 байт | будет выровнен на ```8``` байт |

Вот структура с элементами различных типов, общая длина которой составляет 8 байт перед компиляцией:

**Пример 1**

```cpp
struct MixedData
{
    char Data1;      // 1 байт
    short Data2;     // 2 байт
    int Data3;       // 4 байт
    char Data4;      // 1 байт
};
```

После компиляции структура данных будет дополнена байтами заполнения (```PaddingN```), чтобы обеспечить
правильное выравнивание для каждого из ее элементов:

```cpp
struct MixedData  // Посли компиляции на 32-bit x86 машине
{
    char Data1;       // 1 байт
    char Padding1[1]; // 1 байт для следующего short, который должен быть выровнен по границе в 2 байта
                      // предполагая, что адрес, с которого начинается структура, является четным числом
    short Data2;      // 2 байта
    int Data3;        // 4 байта - самый большой элемент структуры
    char Data4;       // 1 байт
    char Padding2[3]; // 3 байта, чтобы общий размер структуры составил 12 байт
};
```

Итого, после компиляции получим:

```cpp
struct MixedData
{
    char Data1;      // 2 байт
    short Data2;     // 2 байт
    int Data3;       // 4 байт
    char Data4;      // 4 байт
};
```
Скомпилированный размер структуры теперь составляет ```12``` байт. Важно отметить, что последний элемент
дополняется требуемым количеством байтов, так что общий размер структуры должен быть кратен наибольшему
выравниванию любого элемента структуры (в данном случае выравнивание (```int```), которое = 4 в linux-32bit/gcc)

В этом случае к последнему элементу добавляется 3 байта, чтобы заполнить структуру до размера 12 байт
(выравнивание (```int```) × 3).

**Пример 2**

```cpp
struct FinalPad
{
  float x;      // 4 байта
  char n[1];    // 1 байт
};
```

После компиляции получим:

```cpp
struct FinalPad
{
  float x;      // 4 байта
  char n[1];    // 4 байт
};
```

В этом примере общий размер структуры ```sizeof(FinalPad) == 8```, а не ```5```
(так что размер кратен ```4``` (выравнивание по float)).

**Пример 3**

Можно изменить выравнивание структур, чтобы уменьшить объем памяти, который им требуется
(или соответствовать существующему формату), изменив порядок элементов структуры или изменив
выравнивание ("packing") элементов структуры компилятором.

```cpp
struct MixedData  /* after reordering */
{
    char Data1;   // 1 байт
    char Data4;   // Перемещен, 1 байт
    short Data2;  // 2 байта
    int Data3;    // 4 байта
};
```
Скомпилированный размер структуры теперь соответствует предварительному размеру в ```8``` байт. Обратите
внимание, что Padding1[1] было заменено (и, следовательно, устранено) Data4, а Padding2[3] больше не
требуется, поскольку структура уже выровнена по размеру длинного слова.

Альтернативный метод принудительного выравнивания структуры ```MixedData``` по границе в один байт приведет
к тому, что препроцессор отменит предопределенное выравнивание элементов структуры, и, таким образом, байты
заполнения не будут вставлены.

Хотя стандартного способа определения выравнивания элементов структуры не существует, некоторые компиляторы
используют директивы ```#pragma``` для указания упаковки внутри исходных файлов.
Вот пример:

```cpp
#pragma pack(push)  // переместить текущее выравнивание в стек
#pragma pack(1)     // установить выравнивание по границе в 1 байт

struct MyPackedData
{
    char Data1;     // 1 байт
    long Data2;     // 4 байта
    char Data3;     // 1 байт
};

#pragma pack(pop)   // восстановить исходное выравнивание из стека
```

Эта структура будет иметь скомпилированный размер ```6``` байт в 32-разрядной системе. Вышеуказанные
директивы доступны в компиляторах Microsoft, Borland, GNU, и многих других.

Другой пример:

```cpp
struct MyPackedData
{
    char Data1;     // 1 байт
    long Data2;     // 4 байта
    char Data3;     // 1 байт
} __attribute__((packed));
```

**[⬆ Back to Top](#table-of-contents)**


32. ### Что такое union?


Объединения также как и структура хранят набор элементов, но в отличие от структуры все элементы объединения
имеют нулевое смещение. А это значит, что разные элементы занимают в памяти один и тот же участок.

Для определения объединений применяется ключевое слово ```union``` и следующий формальный синтаксис:

```cpp
union code
{
    int digit;
    char letter;
};
```

Для обращения к элементам объединения, как и в случае со структурами, можно использовать операцию ```.```:

```cpp
union code id;
id.digit = 120;

printf("%d - %c \n", id.digit, id.letter);
printf("%d - %d \n", id.digit, id.letter);

id.letter = 87;

printf("%d - %c \n", id.digit, id.letter);
```

```commandline
120 - x
120 - 120
87 - W
```

Стоит отметить, что, так как оба элемента занимают одну и ту же память, то изменение одного из них приведет
к изменению другого. Так так участок памяти один, и данные фактически одни и те же, только при обращении к
```id.digit``` данные интерпретируются как объект ```int```, а при обращении к ```id.letter``` - как
объект ```char```.

Так же, чаще всего, объединения используют в нескольких случаях:

1.  Для создания **«универсального» типа данных**, способного хранить не единственный, а один из
предопределённых типов. Для этого к объединению добавляют целочисленное поле, указывающее тип хранимых
в настоящий момент данных:

```cpp
struct variant
{
    union tag_value
    {
        int intValue;
        float floatValue
    } value;
    unsigned storedType;
};
```

Иными словами, это предшественник современных ```boost::variant```, ```QVariant``` и т. д. Однако
вышеперечисленные классы могут хранить в себе непримитивные типы (с конструкторами, деструкторами и
операторами копирования), а ```union``` — нет.

2. Для преобразования между несовместимыми типами. Традиционно для этих целей используют оператор
преобразования ```(T)```, либо ```reinterpret_cast<>```. Однако эти способы опасны нарушением
```strict aliasing rule``` и, как результат, порождением неопределённого поведения.

Правильные способы преобразования — это либо ```memcpy``` (подобный вызов которого выбрасывается
компилятором), либо использование ```union```-а.

**UPD:** Внимание! Преобразование через ```union``` является допустимым только в ```С```, но не в ```C++```.

3. Один из практических способов использование ```union``` это доступ к битам передаваемой информации.
Допустим передается информация по битно за один раз ```32``` бита.

```cpp
struct _info_s
{
    uint32_t info_a:2;
    uint32_t info_b:10;
    uint32_t info_c:8;
    uint32_t info_d:5;
    uint32_t info_e:5;
    uint32_t info_f:2;
}__atributte__((packed));
typedef struct _info_s  info_s;

union _total_u
{
    uint32_t array;
    info_s info;
};
```

При чтении/записи мы можем сразу оперировать ```uint32_t```, но и доступ к битам появляется сразу.

**[⬆ Back to Top](#table-of-contents)**

33. ### Какой размер union?

Возьмем, к примеру, следующее объединение:

```cpp
union code
{
    int digit;
    char letter;
};
```

Объединение ```code``` хранит в одном и том же участки памяти объект ```int``` и объект ```char```.
Конкретный размер выделенной памяти будет зависеть от системы и реализации, но в общем случае это будет
выглядеть примерно следующим образом:

![union](https://github.com/Xelerezex/interview-space/blob/main/c-plus-plus-questions/img/union.png)

В этом случае объединение сode на большинстве платформ будет занимать 4 байта. Длина элементов, как
здесь, может быть разной, и в этом случае размер объединения вычисляется по наибольшему элементу.

**[⬆ Back to Top](#table-of-contents)**

34. ### Что будет, если дважды вызвать free?

Функцию ```free()``` нельзя вызывать дважды в нераспределенной памяти,т.к. стандарт четко указывает:

Функция ```free``` заставляет пространство, на которое указывает его аргумент, освобождаться, то есть
становится доступным для дальнейшего выделения. Если аргумент является нулевым указателем, никаких
действий не происходит. В противном случае, если аргумент не соответствует указателю, ранее возвращенному
функцией управления памятью, или если пространство было освобождено вызовом ```free``` или ```realloc```,
поведение неопределено.

**[⬆ Back to Top](#table-of-contents)**

35. ### Как происходит вызов функции?

Рассмотрим функцию со следующим прототипом

```cpp
int foo (int arg1, int arg2, int arg3);
```

Функция имеет ```2``` локальных переменных. Далее будем считать, что ```sizeof(int)``` равен ```4```байтам.
Пусть функция ```main``` вызывает функцию ```foo```. Регистр ```ESP``` является указателем стека (хранит
адрес вершины стека), регистр ```EBP``` - указателем базы. Регистр ```EBP``` используется для хранения
адреса предыдущего фрейма. Аргументы, которые ```main``` передаёт ```foo```, а также локальные переменные
могут быть получены путём сдвига относительно указателя базы.

Если вызываемая функция работает с регистрами ```EAX```, ```ECX``` и ```EDX```, то вызывающая функция должна
их сохранить каким-то образом на стеке перед вызовом подпрограммы. С другой стороны, вызываемая функция
должна восстановить значения этих регистров. Если вызываемая функция изменяет состояние регистров ```EAX```,
```ECX``` и ```EDX```, то она должна сначала сохранить предыдущее состояние на стеке, а перед выходом
восстановить их прежние значения.

Параметры, передаваемые функции ```foo``` кладутся на стек справа налево: сначала самый последний аргумент, в
конце самый первый. Локальные переменные, также как и временные, хранятся на стеке.

![funcall](https://github.com/Xelerezex/interview-space/blob/main/c-plus-plus-questions/img/funcall.jpg)

Возвращаемое значение, если оно меньше ```4``` байт, сохраняется в регистре ```EAX```. Если возвращаемое
значение больше четырёх байт, то вызывающая функция передаёт дополнительный первый параметр вызываемой
функции. Этот параметр - адрес, по которому должно быть сохранено возвращаемое значение. На языке си вызов

```cpp
x = foo(a, b, c);
```

будет трансформирован в

```cpp
foo(&x, a, b, c);
```

Заметьте, это произойдёт только если возвращаемое значение больше ```4``` байт.

**[⬆ Back to Top](#table-of-contents)**

