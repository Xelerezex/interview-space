# C++ interview questions:

## Table of Contents


|  No.  | Questions |
| :---: | :-------- |
|       | **[Препроцессор и компиляция](#препроцессор-и-компиляция)** |
|   1   | [Как проходит процесс компиляции срр-файлов в бинарный файл?](#как-проходит-процесс-компиляции-срр-файлов-в-бинарный-файл) |
|   2   | [Что такое препроцессор?](#что-такое-препроцессор) |
|   3   | [Как работает препроцессор?](#как-работает-препроцессор) |
|   4   | [Какие существуют команды препроцессора?](#какие-существуют-команды-препроцессора) |
|   5   | [Как работает директива include?](#как-работает-директива-include) |
|   6   | [Как работает директива define?](#как-работает-директива-define) |
|   7   | [Что именно линкует линкер?](#что-именно-линкует-линкер) |
|   8   | [Что такое оптимизация компилятора?](#что-такое-оптимизация-компилятора) |

### Препроцессор и компиляция:

1. ### Как проходит процесс компиляции срр-файлов в бинарный файл?

Существует 5 стадий преобразования файла:

```
        Препроцессинг -> Компиляция -> Ассемблирование -> Компоновка -> Загрузка
```

-   **Препроцессинг** - все препроцессорные директивы (```#include```, ```#define```, ```#if```,
    ```#ifdef``` и ```#ifndef``` и т.д.) рекурсивно раскрываются и включаются в выпускаемый файл.
    Получается выходной файл с расширением **.ii**. С флагом ```-Е``` можно увидеть выходной файл
    после препроцесинга.

-   **Компиляция** - компилятор преобразует скомпанованный файл в ассемблерный код. Ассемблерный код
    — это доступное для понимания человеком представление машинного кода. Получается выходной файл с
    расширением **.s**. С флагом ```-S``` можно увидеть выходной файл после компиляции.

-   **Ассемблер** - Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в объектном
    файле с расширением **.o**. Объектный файл — это созданный ассемблером промежуточный файл, хранящий
    кусок машинного кода. Далее возможно сохранение данного объектного кода в статические библиотеки для
    того, чтобы не компилировать данный код снова.

-   **Компоновщик (линкер)** - вязывает все объектные файлы и статические библиотеки в единый исполняемый
    файл, который мы и сможем запустить в дальнейшем.

-   **Загрузка** - вызывается загрузчик для загрузки нашей программы в память. На данной стадии также
    возможна подгрузка динамических библиотек.

**[⬆ Back to Top](#table-of-contents)**

2. ### Что такое препроцессор?

**Препроцессор** — это компьютерная программа, принимающая данные на входе и выдающая данные,
предназначенные для входа другой программы (например, компилятора). О данных на выходе препроцессора
говорят, что они находятся в препроцессированной форме, пригодной для обработки последующими программами
(компилятором).


**[⬆ Back to Top](#table-of-contents)**

3. ### Как работает препроцессор?

Препроцессор предназначен для предварительной обработки текста программы. Препроцессор позволяет включать в
текст программы файлы и вводить макроопределения. Работа препроцессора осуществляется с помощью специальных
директив (указаний). Они отмечаются знаком решетка ```#```. По окончании строк, обозначающих директивы в
языке Си, точку с запятой можно не ставить.

**[⬆ Back to Top](#table-of-contents)**

4. ### Какие существуют команды препроцессора?

-   ```#include``` — вставляет текст из указанного файла.

-   ```#using``` — импортирует метаданные в программу.

-   ```#define``` — задаёт макроопределение (макрос) или символическую константу.

-   ```#undef``` — отменяет предыдущее определение.

-   ```#if``` — осуществляет условную компиляцию при истинности константного выражения.

-   ```#ifdef``` — осуществляет условную компиляцию при определённости символической константы.

-   ```#ifndef``` — осуществляет условную компиляцию при неопределённости символической константы.

-   ```#else``` — ветка условной компиляции при ложности выражения.

-   ```#elif``` — ветка условной компиляции, образуемая слиянием ```else``` и ```if```.

-   ```#endif``` — конец ветки условной компиляции.

-   ```#line``` — препроцессор изменяет номер текущей строки и имя компилируемого файла.

-   ```#error``` — выдача диагностического сообщения.

-   ```#pragma``` — действие, зависящее от конкретной реализации компилятора.

-   ```#import``` — используется для включения сведений из библиотеки типов.

**[⬆ Back to Top](#table-of-contents)**

5. ### Как работает директива include?

Директива ```#include``` включает полный текст системных файлов или файлов пользователя на то место, где
она стоит в коде.

Существует три модификации директивы ```#include```:

-   ```#include <FILE>``` — Эта модификация используется для подключения системных файлов. При ее
    выполнении производится поиск файла с именем ```FILE``` в списке указанных заранее каталогов,
    а затем в стандартном списке системных каталогов.

-   ```#include "FILE"``` — Эта модификация применяется для подключаемых файлов для программ пользователя.
    Сначала файл ```FILE``` просматривается в текущем каталоге, а затем в каталогах для системных
    подключаемых файлов.

-   ```#include ANYTHING ELSE``` — Эта модификация называется "вычисляемой директивой ```#include```".
    Строка ```ANYTHING ELSE``` проверяется на наличие соответствующего макроса, значение которого затем
    заменяет его название. Полученная в результате строка должна уже в точности соответствовать одной из
    рассмотренных выше модификаций(то есть имя подключаемого файла должно быть заключено в кавычки или
    угловые скобки).

**[⬆ Back to Top](#table-of-contents)**

6. ### Как работает директива define?

Директива ```#define``` позволяет вводить в текст программы константы и макроопределения.
Общая форма записи

```cpp
    #define ID REPLACEMENT
```

Поля ```ID``` и ```REPLACEMENT``` разделяются одним или несколькими пробелами.
Директива ```#define``` указывает компилятору, что нужно подставить строку, определенную аргументом
```REPLACEMENT```, вместо каждого аргумента ```ID``` в исходном файле. ```ID``` не заменяется, если он
находится в комментарии, в строке или как часть более длинного идентификатора.

**[⬆ Back to Top](#table-of-contents)**

7. ### Что именно линкует линкер?

**Линкер** — программа, которая производит компоновку («линковку»): принимает на вход один или
несколько объектных модулей и собирает из них исполняемый или библиотечный файл-модуль.
Кокретнее для ```С/С++```: где-то в коде будет объявление переменной или функции. Это значит
что где-то будет и определение. Задача линкера - соеденить объявление и определение функции,
переменных и т.д.

**[⬆ Back to Top](#table-of-contents)**

8. ### Что такое оптимизация компилятора?

**Оптимизация** — это процесс преобразования части кода в другую функционально эквивалентную часть для
улучшения одной или более характеристик кода. Две самые важные характеристики — это скорость работы и размер
кода. Как пример: достигается через флаги компиляции, на этапе компиляции программы.

**[⬆ Back to Top](#table-of-contents)**
