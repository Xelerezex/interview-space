# C++ interview questions:

## Table of Contents


|  No.  | Questions |
| :---: | :-------- |
|       | **[Препроцессор и компиляция](#препроцессор-и-компиляция)** |
|   1   | [Как проходит процесс компиляции срр-файлов в бинарный файл?](#как-проходит-процесс-компиляции-срр-файлов-в-бинарный-файл) |
|   2   | [Что такое препроцессор?](#что-такое-препроцессор) |
|   3   | [Как работает препроцессор?](#как-работает-препроцессор) |
|   4   | [Какие существуют команды препроцессора?](#какие-существуют-команды-препроцессора) |
|   5   | [Как работает директива include?](#как-работает-директива-include) |
|   6   | [Как работает директива define?](#как-работает-директива-define) |
|   7   | [Что именно линкует линкер?](#что-именно-линкует-линкер) |
|   8   | [Что такое оптимизация компилятора?](#что-такое-оптимизация-компилятора) |
|   9.  | [Что такое флаги компиляции?](#что-такое-флаги-компиляции) |
|   10. | [Как защитить хедер от повторного включения?](#как-защитить-хедер-от-повторного-включения) |
|   11. | [Расскажите о системах автоматизации билд-процесса](#расскажите-о-системах-автоматизации-билд-процесса) |
|   12. | [Какая разница между статической и динамической библиотеками?](#какая-разница-между-статической-и-динамической-библиотеками) |
|   13. | [Что такое DLL hell?](#что-такое-dll-hell) |
|   14. | [Что такое флаг компиляции -fPIC?](#что-такое-флаг-компиляции--fpic?) |
|   15. | [В чем разница между дебаженной и релизной сборкой?](#в-чем-разница-между-дебаженной-и-релизной-сборкой) |
|   16. | Что такое internal linkage? |

### Препроцессор и компиляция:

1. ### Как проходит процесс компиляции срр-файлов в бинарный файл?

Существует 5 стадий преобразования файла:

```
        Препроцессинг -> Компиляция -> Ассемблирование -> Компоновка -> Загрузка
```

-   **Препроцессинг** - все препроцессорные директивы (```#include```, ```#define```, ```#if```,
    ```#ifdef``` и ```#ifndef``` и т.д.) рекурсивно раскрываются и включаются в выпускаемый файл.
    Получается выходной файл с расширением **.ii**. С флагом ```-Е``` можно увидеть выходной файл
    после препроцесинга.

-   **Компиляция** - компилятор преобразует скомпанованный файл в ассемблерный код. Ассемблерный код
    — это доступное для понимания человеком представление машинного кода. Получается выходной файл с
    расширением **.s**. С флагом ```-S``` можно увидеть выходной файл после компиляции.

-   **Ассемблер** - Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в объектном
    файле с расширением **.o**. Объектный файл — это созданный ассемблером промежуточный файл, хранящий
    кусок машинного кода. Далее возможно сохранение данного объектного кода в статические библиотеки для
    того, чтобы не компилировать данный код снова.

-   **Компоновщик (линкер)** - вязывает все объектные файлы и статические библиотеки в единый исполняемый
    файл, который мы и сможем запустить в дальнейшем.

-   **Загрузка** - вызывается загрузчик для загрузки нашей программы в память. На данной стадии также
    возможна подгрузка динамических библиотек.

**[⬆ Back to Top](#table-of-contents)**

2. ### Что такое препроцессор?

**Препроцессор** — это компьютерная программа, принимающая данные на входе и выдающая данные,
предназначенные для входа другой программы (например, компилятора). О данных на выходе препроцессора
говорят, что они находятся в препроцессированной форме, пригодной для обработки последующими программами
(компилятором).


**[⬆ Back to Top](#table-of-contents)**

3. ### Как работает препроцессор?

Препроцессор предназначен для предварительной обработки текста программы. Препроцессор позволяет включать в
текст программы файлы и вводить макроопределения. Работа препроцессора осуществляется с помощью специальных
директив (указаний). Они отмечаются знаком решетка ```#```. По окончании строк, обозначающих директивы в
языке Си, точку с запятой можно не ставить.

**[⬆ Back to Top](#table-of-contents)**

4. ### Какие существуют команды препроцессора?

-   ```#include``` — вставляет текст из указанного файла.

-   ```#using``` — импортирует метаданные в программу.

-   ```#define``` — задаёт макроопределение (макрос) или символическую константу.

-   ```#undef``` — отменяет предыдущее определение.

-   ```#if``` — осуществляет условную компиляцию при истинности константного выражения.

-   ```#ifdef``` — осуществляет условную компиляцию при определённости символической константы.

-   ```#ifndef``` — осуществляет условную компиляцию при неопределённости символической константы.

-   ```#else``` — ветка условной компиляции при ложности выражения.

-   ```#elif``` — ветка условной компиляции, образуемая слиянием ```else``` и ```if```.

-   ```#endif``` — конец ветки условной компиляции.

-   ```#line``` — препроцессор изменяет номер текущей строки и имя компилируемого файла.

-   ```#error``` — выдача диагностического сообщения.

-   ```#pragma``` — действие, зависящее от конкретной реализации компилятора.

-   ```#import``` — используется для включения сведений из библиотеки типов.

**[⬆ Back to Top](#table-of-contents)**

5. ### Как работает директива include?

Директива ```#include``` включает полный текст системных файлов или файлов пользователя на то место, где
она стоит в коде.

Существует три модификации директивы ```#include```:

-   ```#include <FILE>``` — Эта модификация используется для подключения системных файлов. При ее
    выполнении производится поиск файла с именем ```FILE``` в списке указанных заранее каталогов,
    а затем в стандартном списке системных каталогов.

-   ```#include "FILE"``` — Эта модификация применяется для подключаемых файлов для программ пользователя.
    Сначала файл ```FILE``` просматривается в текущем каталоге, а затем в каталогах для системных
    подключаемых файлов.

-   ```#include ANYTHING ELSE``` — Эта модификация называется "вычисляемой директивой ```#include```".
    Строка ```ANYTHING ELSE``` проверяется на наличие соответствующего макроса, значение которого затем
    заменяет его название. Полученная в результате строка должна уже в точности соответствовать одной из
    рассмотренных выше модификаций(то есть имя подключаемого файла должно быть заключено в кавычки или
    угловые скобки).

**[⬆ Back to Top](#table-of-contents)**

6. ### Как работает директива define?

Директива ```#define``` позволяет вводить в текст программы константы и макроопределения.
Общая форма записи

```cpp
    #define ID REPLACEMENT
```

Поля ```ID``` и ```REPLACEMENT``` разделяются одним или несколькими пробелами.
Директива ```#define``` указывает компилятору, что нужно подставить строку, определенную аргументом
```REPLACEMENT```, вместо каждого аргумента ```ID``` в исходном файле. ```ID``` не заменяется, если он
находится в комментарии, в строке или как часть более длинного идентификатора.

**[⬆ Back to Top](#table-of-contents)**

7. ### Что именно линкует линкер?

**Линкер** — программа, которая производит компоновку («линковку»): принимает на вход один или
несколько объектных модулей и собирает из них исполняемый или библиотечный файл-модуль.
Кокретнее для ```С/С++```: где-то в коде будет объявление переменной или функции. Это значит
что где-то будет и определение. Задача линкера - соеденить объявление и определение функции,
переменных и т.д.

**[⬆ Back to Top](#table-of-contents)**

8. ### Что такое оптимизация компилятора?

**Оптимизация** — это процесс преобразования части кода в другую функционально эквивалентную часть для
улучшения одной или более характеристик кода. Две самые важные характеристики — это скорость работы и размер
кода. Как пример: достигается через флаги компиляции, на этапе компиляции программы.

**[⬆ Back to Top](#table-of-contents)**

9. ### Что такое флаги компиляции?

**Флаг компиляции** - это специальная настройка передаваемая компилятору во время препроцессирование,
компиляции, ассемблировании или при линковке.

**[⬆ Back to Top](#table-of-contents)**

10. ### Как защитить хедер от повторного включения?

В чистом ```С``` для этого нужно обернуть хедер следующим выражением:

```c
#ifndef H_HEADER
#define H_HEADER

// Header itself

#endif
```

В ```С++``` чаще применяется следующая деректива препроцессора в начале хедера:

```cpp
#pragma once
```

**[⬆ Back to Top](#table-of-contents)**

11. ### Расскажите о системах автоматизации билд-процесса.

**Автоматизация сборки** — этап процесса разработки программного обеспечения, заключающийся в автоматизации
широкого спектра задач, решаемых программистами в их повседневной деятельности.

Включает такие действия, как:

-   компиляция исходного кода в объектный модуль,

-   сборка бинарного кода в исполняемый файл,

-   выполнение тестов,

-   развёртывание программы в целевой среде,

-   написание сопроводительной документации или описание изменений новой версии.

Для автоматизации нужно написать специальный скрипт, в котором будут описаны все этапы сюорки программы.
Самый частый формат - ```Makefile```. Этот формат читает большинство инструментов для сборки, таких как:

-   Automake.

-   CMake.

-   qmake.

-   imake.

и т.д.

**[⬆ Back to Top](#table-of-contents)**

12. ### Какая разница между статической и динамической библиотеками?

**Статическая библиотека** - это архив объектных файлов, который используется в процессе статической линковки.
В результате статической линковки из многих объектных файлов получается один исполняемый, запускается
статическая линковка в момент создания исполняемого файла. Особенностью является то, что исполняемый файл
содержит полную копию кода библиотеки.

**Динамическая библиотека** - Динамическая линковка запускается в момент создания процесса (когда вы запускаете
исполняемый файл на выполнение), линкуются между собой несколько исполняемых файлов каждый раз, когда создается
новый процесс. Так же возможна динамическая линковка уже после запуска, т.е. новая библиотека может быть подгружена
в адресное пространство ужа работающего процесса. Особенностью является то, что динамическая библиотека содержит
код и данные, которые могут использоваться несколькими программами одновременно. DLL не является исполняемым.
файлом. Динамическое связывание позволяет процессу вызывать функции, не являющиеся частью его исполняемого кода.
Исполняемый код функции находится в DLL, которая содержит одну или несколько функций, которые были скомпилированы,
связаны и хранятся отдельно от процесса, который их использует.

**[⬆ Back to Top](#table-of-contents)**

13. ### Что такое DLL hell?

**DLL hell** - тупиковая ситуация, связанная с управлением динамическими библиотеками ```DLL``` в операционной
системе Microsoft Windows. Аналогичная проблема в других ОС носит название ```Dependency hell```.

Сущность проблемы заключается в конфликте версий ```DLL``, призванных поддерживать определённые функции.
```DLL hell``` — пример плохой концепции программирования, которая, подобно скрытой мине, приводит к
резкому возрастанию трудностей при усложнении и совершенствовании системы.

По исходному замыслу, ```DLL``` должны быть совместимыми от версии к версии и взаимозаменяемыми в обе стороны.

Реализация механизма ```DLL``` такова, что несовместимость и невзаимозаменяемость становится скорее правилом,
чем исключением, что приводит к большому количеству проблем.

-    Отсутствие стандартов на имена, версии и положение ```DLL``` в файловой структуре приводит к тому, что
     несовместимые ```DLL``` легко замещают или отключают друг друга.

-    Отсутствие стандарта на процедуру установки приводит к тому, что установка новых программ приводит к
     замещению работающих ```DLL``` на несовместимые версии.

-    Отсутствие поддержки ```DLL``` со стороны компоновщиков и механизмов защиты приводит к тому, что
     несовместимые ```DLL``` могут иметь одинаковые имя и версию.

-    Отсутствуют стандартные инструменты идентификации и управления системой ```DLL``` пользователями и
     администраторами.

-    Использование отдельных ```DLL``` для обеспечения связи между задачами приводит к нестабильности сложных
     приложений.

**[⬆ Back to Top](#table-of-contents)**

14. Что такое флаг компиляции -fPIC?

**Флаг -fPIC** - это компиляция позиционно-независимого кода. Только из таких кодов можно сделать
динамическую библиотеку с разделяемыми кодами. Если компилировать модули без -fPIC и потом собрать
*.so, то формально динамическая библиотека получится, но код будет не разделяемым. Для каждого
процесса, использующего этот модуль, будет создаваться копия кодов. Флаг -fPIC нужен для компиляции из
исходника в объектник, для линковки не нужен. "Нормальный" процесс выглядит так:

```commandline
gcc t1.c -c -fPIC
gcc t2.c -c -fPIC
gcc t3.c -c -fPIC
gcc -shared t1.o t2.o t2.o -o libqqq.so
```

**[⬆ Back to Top](#table-of-contents)**

15. ### В чем разница между дебаженной и релизной сборкой?

**Конфигурация сборки** — это набор настроек проекта, которые определяют принцип его построения. Конфигурация
сборки состоит из:

-   имени исполняемого файла;

-   имени директории исполняемого файла;

-   имён директорий, в которых IDE будет искать другой код и файлы библиотек;

-   информации об отладке и параметрах оптимизации вашего проекта.

**Конфигурация Debug** предназначена для отладки программы. Эта конфигурация отключает все настройки по
оптимизации, включает информацию об отладке, что делает программы больше и медленнее, но упрощает
проведение отладки. Режим ```Debug``` обычно используется в качестве конфигурации по умолчанию.

**Конфигурация Release** используется во время сборки программы для её дальнейшего выпуска. Программа
оптимизируется по размеру и производительности и не содержит дополнительную информацию об отладке.

**[⬆ Back to Top](#table-of-contents)**

16. ### Что такое internal linkage?

https://www.goldsborough.me/c/c++/linker/2016/03/30/19-34-25-internal_and_external_linkage_in_c++/

**[⬆ Back to Top](#table-of-contents)**
