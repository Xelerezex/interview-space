# C++ interview questions:

## Table of Contents:

## Препроцессор и компиляция:
- [Вопрос 1. Как проходит процесс компиляции срр-файлов в бинарный файл?](#вопрос-1-как-проходит-процесс-компиляции-срр-файлов-в-бинарный-файл)
- [Вопрос 2. Что такое препроцессор?](#вопрос-2-что-такое-препроцессор)
- [Вопрос 3. Как работает препроцессор?](#вопрос-3-как-работает-препроцессор)
- [Вопрос 4. Какие существуют команды препроцессора?](#вопрос-4-какие-существуют-команды-препроцессора)
- [Вопрос 5. Как работает директива include?](#вопрос-5-как-работает-директива-include)
- [Вопрос 6. Как работает директива define?](#вопрос-6-как-работает-директива-define)
- [Вопрос 7. Что именно линкует линкер?](#вопрос-7-что-именно-линкует-линкер)
- [Вопрос 8. Что такое оптимизация компилятора?](#вопрос-8-что-такое-оптимизация-компилятора)

## Препроцессор и компиляция:

### Вопрос 1. Как проходит процесс компиляции срр-файлов в бинарный файл?
### Ответ:

Существует 5 стадий преобразования файла:

```
        Препроцессинг -> Компиляция -> Ассемблирование -> Компоновка -> Загрузка
```

-   **Препроцессинг** - все препроцессорные директивы (```#include```, ```#define```, ```#if```,
    ```#ifdef``` и ```#ifndef``` и т.д.) рекурсивно раскрываются и включаются в выпускаемый файл.
    Получается выходной файл с расширением **.ii**. С флагом ```-Е``` можно увидеть выходной файл
    после препроцесинга.

-   **Компиляция** - компилятор преобразует скомпанованный файл в ассемблерный код. Ассемблерный код
    — это доступное для понимания человеком представление машинного кода. Получается выходной файл с
    расширением **.s**. С флагом ```-S``` можно увидеть выходной файл после компиляции.

-   **Ассемблер** - Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в объектном
    файле с расширением **.o**. Объектный файл — это созданный ассемблером промежуточный файл, хранящий
    кусок машинного кода. Далее возможно сохранение данного объектного кода в статические библиотеки для
    того, чтобы не компилировать данный код снова.

-   **Компоновщик (линкер)** - вязывает все объектные файлы и статические библиотеки в единый исполняемый
    файл, который мы и сможем запустить в дальнейшем.

-   **Загрузка** - вызывается загрузчик для загрузки нашей программы в память. На данной стадии также
    возможна подгрузка динамических библиотек.

### Вопрос 2. Что такое препроцессор?
### Ответ:

**Препроцессор** — это компьютерная программа, принимающая данные на входе и выдающая данные,
предназначенные для входа другой программы (например, компилятора). О данных на выходе препроцессора
говорят, что они находятся в препроцессированной форме, пригодной для обработки последующими программами
(компилятором).

### Вопрос 3. Как работает препроцессор?
### Ответ:

Препроцессор предназначен для предварительной обработки текста программы. Препроцессор позволяет включать в
текст программы файлы и вводить макроопределения. Работа препроцессора осуществляется с помощью специальных
директив (указаний). Они отмечаются знаком решетка ```#```. По окончании строк, обозначающих директивы в
языке Си, точку с запятой можно не ставить.

### Вопрос 4. Какие существуют команды препроцессора?
### Ответ:

-   ```#include``` — вставляет текст из указанного файла.

-   ```#using``` — импортирует метаданные в программу.

-   ```#define``` — задаёт макроопределение (макрос) или символическую константу.

-   ```#undef``` — отменяет предыдущее определение.

-   ```#if``` — осуществляет условную компиляцию при истинности константного выражения.

-   ```#ifdef``` — осуществляет условную компиляцию при определённости символической константы.

-   ```#ifndef``` — осуществляет условную компиляцию при неопределённости символической константы.

-   ```#else``` — ветка условной компиляции при ложности выражения.

-   ```#elif``` — ветка условной компиляции, образуемая слиянием ```else``` и ```if```.

-   ```#endif``` — конец ветки условной компиляции.

-   ```#line``` — препроцессор изменяет номер текущей строки и имя компилируемого файла.

-   ```#error``` — выдача диагностического сообщения.

-   ```#pragma``` — действие, зависящее от конкретной реализации компилятора.

-   ```#import``` — используется для включения сведений из библиотеки типов.

https://www.opennet.ru/docs/RUS/cpp/cpp-4.html

### Вопрос 5. Как работает директива include?
### Ответ:

Директива ```#include``` включает полный текст системных файлов или файлов пользователя на то место, где
она стоит в коде.

Существует три модификации директивы ```#include```:

-   ```#include <FILE>``` — Эта модификация используется для подключения системных файлов. При ее
    выполнении производится поиск файла с именем ```FILE``` в списке указанных заранее каталогов,
    а затем в стандартном списке системных каталогов.

-   ```#include "FILE"``` — Эта модификация применяется для подключаемых файлов для программ пользователя.
    Сначала файл ```FILE``` просматривается в текущем каталоге, а затем в каталогах для системных
    подключаемых файлов.

-   ```#include ANYTHING ELSE``` — Эта модификация называется "вычисляемой директивой ```#include```".
    Строка ```ANYTHING ELSE``` проверяется на наличие соответствующего макроса, значение которого затем
    заменяет его название. Полученная в результате строка должна уже в точности соответствовать одной из
    рассмотренных выше модификаций(то есть имя подключаемого файла должно быть заключено в кавычки или
    угловые скобки).

### Вопрос 6. Как работает директива define?
### Ответ:

Директива ```#define``` позволяет вводить в текст программы константы и макроопределения.
Общая форма записи

```cpp
    #define ID REPLACEMENT
```

Поля ```ID``` и ```REPLACEMENT``` разделяются одним или несколькими пробелами.
Директива ```#define``` указывает компилятору, что нужно подставить строку, определенную аргументом
```REPLACEMENT```, вместо каждого аргумента ```ID``` в исходном файле. ```ID``` не заменяется, если он
находится в комментарии, в строке или как часть более длинного идентификатора.


### Вопрос 7. Что именно линкует линкер?
### Ответ:

**Линкер** — программа, которая производит компоновку («линковку»): принимает на вход один или
несколько объектных модулей и собирает из них исполняемый или библиотечный файл-модуль.
Кокретнее для ```С/С++```: где-то в коде будет объявление переменной или функции. Это значит
что где-то будет и определение. Задача линкера - соеденить объявление и определение функции,
переменных и т.д.

### Вопрос 8. Что такое оптимизация компилятора?
### Ответ:

**Оптимизация** — это процесс преобразования части кода в другую функционально эквивалентную часть для
улучшения одной или более характеристик кода. Две самые важные характеристики — это скорость работы и размер
кода. Как пример: достигается через флаги компиляции, на этапе компиляции программы.

