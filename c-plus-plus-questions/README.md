# C++ interview questions:

## Table of Contents


|  No.  | Questions |
| :---: | :-------- |
|       | **[Препроцессор и компиляция](#препроцессор-и-компиляция)** |
|   1   | [Как проходит процесс компиляции срр-файлов в бинарный файл?](#как-проходит-процесс-компиляции-срр-файлов-в-бинарный-файл) |
|   2   | [Что такое препроцессор?](#что-такое-препроцессор) |
|   3   | [Как работает препроцессор?](#как-работает-препроцессор) |
|   4   | [Какие существуют команды препроцессора?](#какие-существуют-команды-препроцессора) |
|   5   | [Как работает директива include?](#как-работает-директива-include) |
|   6   | [Как работает директива define?](#как-работает-директива-define) |
|   7   | [Что именно линкует линкер?](#что-именно-линкует-линкер) |
|   8   | [Что такое оптимизация компилятора?](#что-такое-оптимизация-компилятора) |
|   9.  | [Что такое флаги компиляции?](#что-такое-флаги-компиляции) |
|   10. | [Как защитить хедер от повторного включения?](#как-защитить-хедер-от-повторного-включения) |
|   11. | [Расскажите о системах автоматизации билд-процесса](#расскажите-о-системах-автоматизации-билд-процесса) |
|   12. | [Какая разница между статической и динамической библиотеками?](#какая-разница-между-статической-и-динамической-библиотеками) |
|   13. | [Что такое DLL hell?](#что-такое-dll-hell) |
|   14. | [Что такое флаг компиляции -fPIC?](#что-такое-флаг-компиляции--fpic) |
|   15. | [В чем разница между дебаженной и релизной сборкой?](#в-чем-разница-между-дебаженной-и-релизной-сборкой) |
|   16. | [Что такое internal linkage?](#что-такое-internal-linkage) |
|   17. | [Что такое барьеры памяти?](#что-такое-барьеры-памяти) |
|       | **[C](#c)** |
|   18. | [В каких случаях используется ключевое слово static?](#в-каких-случаях-используется-ключевое-слово-static) |
|   19. | [Что означает ключевое слово const?](#что-означает-ключевое-слово-const) |
|   20. | [Что означает ключевое слово extern?](#что-означает-ключевое-слово-extern) |
|   21. | [Что означает ключевое слово volatile?](#что-означает-ключевое-слово-volatile) |
|   22. | [Какие есть битовые операции?](#какие-есть-битовые-операции) |
|   23. | [Где хранятся переменные в памяти?](#где-хранятся-переменные-в-памяти) |
### Препроцессор и компиляция:

1. ### Как проходит процесс компиляции срр-файлов в бинарный файл?

Существует 5 стадий преобразования файла:

```
        Препроцессинг -> Компиляция -> Ассемблирование -> Компоновка -> Загрузка
```

-   **Препроцессинг** - все препроцессорные директивы (```#include```, ```#define```, ```#if```,
    ```#ifdef``` и ```#ifndef``` и т.д.) рекурсивно раскрываются и включаются в выпускаемый файл.
    Получается выходной файл с расширением **.ii**. С флагом ```-Е``` можно увидеть выходной файл
    после препроцесинга.

-   **Компиляция** - компилятор преобразует скомпанованный файл в ассемблерный код. Ассемблерный код
    — это доступное для понимания человеком представление машинного кода. Получается выходной файл с
    расширением **.s**. С флагом ```-S``` можно увидеть выходной файл после компиляции.

-   **Ассемблер** - Ассемблер преобразовывает ассемблерный код в машинный код, сохраняя его в объектном
    файле с расширением **.o**. Объектный файл — это созданный ассемблером промежуточный файл, хранящий
    кусок машинного кода. Далее возможно сохранение данного объектного кода в статические библиотеки для
    того, чтобы не компилировать данный код снова.

-   **Компоновщик (линкер)** - вязывает все объектные файлы и статические библиотеки в единый исполняемый
    файл, который мы и сможем запустить в дальнейшем.

-   **Загрузка** - вызывается загрузчик для загрузки нашей программы в память. На данной стадии также
    возможна подгрузка динамических библиотек.

**[⬆ Back to Top](#table-of-contents)**

2. ### Что такое препроцессор?

**Препроцессор** — это компьютерная программа, принимающая данные на входе и выдающая данные,
предназначенные для входа другой программы (например, компилятора). О данных на выходе препроцессора
говорят, что они находятся в препроцессированной форме, пригодной для обработки последующими программами
(компилятором).


**[⬆ Back to Top](#table-of-contents)**

3. ### Как работает препроцессор?

Препроцессор предназначен для предварительной обработки текста программы. Препроцессор позволяет включать в
текст программы файлы и вводить макроопределения. Работа препроцессора осуществляется с помощью специальных
директив (указаний). Они отмечаются знаком решетка ```#```. По окончании строк, обозначающих директивы в
языке Си, точку с запятой можно не ставить.

**[⬆ Back to Top](#table-of-contents)**

4. ### Какие существуют команды препроцессора?

-   ```#include``` — вставляет текст из указанного файла.

-   ```#using``` — импортирует метаданные в программу.

-   ```#define``` — задаёт макроопределение (макрос) или символическую константу.

-   ```#undef``` — отменяет предыдущее определение.

-   ```#if``` — осуществляет условную компиляцию при истинности константного выражения.

-   ```#ifdef``` — осуществляет условную компиляцию при определённости символической константы.

-   ```#ifndef``` — осуществляет условную компиляцию при неопределённости символической константы.

-   ```#else``` — ветка условной компиляции при ложности выражения.

-   ```#elif``` — ветка условной компиляции, образуемая слиянием ```else``` и ```if```.

-   ```#endif``` — конец ветки условной компиляции.

-   ```#line``` — препроцессор изменяет номер текущей строки и имя компилируемого файла.

-   ```#error``` — выдача диагностического сообщения.

-   ```#pragma``` — действие, зависящее от конкретной реализации компилятора.

-   ```#import``` — используется для включения сведений из библиотеки типов.

**[⬆ Back to Top](#table-of-contents)**

5. ### Как работает директива include?

Директива ```#include``` включает полный текст системных файлов или файлов пользователя на то место, где
она стоит в коде.

Существует три модификации директивы ```#include```:

-   ```#include <FILE>``` — Эта модификация используется для подключения системных файлов. При ее
    выполнении производится поиск файла с именем ```FILE``` в списке указанных заранее каталогов,
    а затем в стандартном списке системных каталогов.

-   ```#include "FILE"``` — Эта модификация применяется для подключаемых файлов для программ пользователя.
    Сначала файл ```FILE``` просматривается в текущем каталоге, а затем в каталогах для системных
    подключаемых файлов.

-   ```#include ANYTHING ELSE``` — Эта модификация называется "вычисляемой директивой ```#include```".
    Строка ```ANYTHING ELSE``` проверяется на наличие соответствующего макроса, значение которого затем
    заменяет его название. Полученная в результате строка должна уже в точности соответствовать одной из
    рассмотренных выше модификаций(то есть имя подключаемого файла должно быть заключено в кавычки или
    угловые скобки).

**[⬆ Back to Top](#table-of-contents)**

6. ### Как работает директива define?

Директива ```#define``` позволяет вводить в текст программы константы и макроопределения.
Общая форма записи

```cpp
    #define ID REPLACEMENT
```

Поля ```ID``` и ```REPLACEMENT``` разделяются одним или несколькими пробелами.
Директива ```#define``` указывает компилятору, что нужно подставить строку, определенную аргументом
```REPLACEMENT```, вместо каждого аргумента ```ID``` в исходном файле. ```ID``` не заменяется, если он
находится в комментарии, в строке или как часть более длинного идентификатора.

**[⬆ Back to Top](#table-of-contents)**

7. ### Что именно линкует линкер?

**Линкер** — программа, которая производит компоновку («линковку»): принимает на вход один или
несколько объектных модулей и собирает из них исполняемый или библиотечный файл-модуль.
Кокретнее для ```С/С++```: где-то в коде будет объявление переменной или функции. Это значит
что где-то будет и определение. Задача линкера - соеденить объявление и определение функции,
переменных и т.д.

**[⬆ Back to Top](#table-of-contents)**

8. ### Что такое оптимизация компилятора?

**Оптимизация** — это процесс преобразования части кода в другую функционально эквивалентную часть для
улучшения одной или более характеристик кода. Две самые важные характеристики — это скорость работы и размер
кода. Как пример: достигается через флаги компиляции, на этапе компиляции программы.

**[⬆ Back to Top](#table-of-contents)**

9. ### Что такое флаги компиляции?

**Флаг компиляции** - это специальная настройка передаваемая компилятору во время препроцессирование,
компиляции, ассемблировании или при линковке.

**[⬆ Back to Top](#table-of-contents)**

10. ### Как защитить хедер от повторного включения?

В чистом ```С``` для этого нужно обернуть хедер следующим выражением:

```c
#ifndef H_HEADER
#define H_HEADER

// Header itself

#endif
```

В ```С++``` чаще применяется следующая деректива препроцессора в начале хедера:

```cpp
#pragma once
```

**[⬆ Back to Top](#table-of-contents)**

11. ### Расскажите о системах автоматизации билд-процесса.

**Автоматизация сборки** — этап процесса разработки программного обеспечения, заключающийся в автоматизации
широкого спектра задач, решаемых программистами в их повседневной деятельности.

Включает такие действия, как:

-   компиляция исходного кода в объектный модуль,

-   сборка бинарного кода в исполняемый файл,

-   выполнение тестов,

-   развёртывание программы в целевой среде,

-   написание сопроводительной документации или описание изменений новой версии.

Для автоматизации нужно написать специальный скрипт, в котором будут описаны все этапы сюорки программы.
Самый частый формат - ```Makefile```. Этот формат читает большинство инструментов для сборки, таких как:

-   Automake.

-   CMake.

-   qmake.

-   imake.

и т.д.

**[⬆ Back to Top](#table-of-contents)**

12. ### Какая разница между статической и динамической библиотеками?

**Статическая библиотека** - это архив объектных файлов, который используется в процессе статической линковки.
В результате статической линковки из многих объектных файлов получается один исполняемый, запускается
статическая линковка в момент создания исполняемого файла. Особенностью является то, что исполняемый файл
содержит полную копию кода библиотеки.

**Динамическая библиотека** - Динамическая линковка запускается в момент создания процесса (когда вы запускаете
исполняемый файл на выполнение), линкуются между собой несколько исполняемых файлов каждый раз, когда создается
новый процесс. Так же возможна динамическая линковка уже после запуска, т.е. новая библиотека может быть подгружена
в адресное пространство ужа работающего процесса. Особенностью является то, что динамическая библиотека содержит
код и данные, которые могут использоваться несколькими программами одновременно. DLL не является исполняемым.
файлом. Динамическое связывание позволяет процессу вызывать функции, не являющиеся частью его исполняемого кода.
Исполняемый код функции находится в DLL, которая содержит одну или несколько функций, которые были скомпилированы,
связаны и хранятся отдельно от процесса, который их использует.

**[⬆ Back to Top](#table-of-contents)**

13. ### Что такое DLL hell?

**DLL hell** - тупиковая ситуация, связанная с управлением динамическими библиотеками ```DLL``` в операционной
системе Microsoft Windows. Аналогичная проблема в других ОС носит название ```Dependency hell```.

Сущность проблемы заключается в конфликте версий ```DLL```, призванных поддерживать определённые функции.
```DLL hell``` — пример плохой концепции программирования, которая, подобно скрытой мине, приводит к
резкому возрастанию трудностей при усложнении и совершенствовании системы.

По исходному замыслу, ```DLL``` должны быть совместимыми от версии к версии и взаимозаменяемыми в обе стороны.

Реализация механизма ```DLL``` такова, что несовместимость и невзаимозаменяемость становится скорее правилом,
чем исключением, что приводит к большому количеству проблем.

-    Отсутствие стандартов на имена, версии и положение ```DLL``` в файловой структуре приводит к тому, что
     несовместимые ```DLL``` легко замещают или отключают друг друга.

-    Отсутствие стандарта на процедуру установки приводит к тому, что установка новых программ приводит к
     замещению работающих ```DLL``` на несовместимые версии.

-    Отсутствие поддержки ```DLL``` со стороны компоновщиков и механизмов защиты приводит к тому, что
     несовместимые ```DLL``` могут иметь одинаковые имя и версию.

-    Отсутствуют стандартные инструменты идентификации и управления системой ```DLL``` пользователями и
     администраторами.

-    Использование отдельных ```DLL``` для обеспечения связи между задачами приводит к нестабильности сложных
     приложений.

**[⬆ Back to Top](#table-of-contents)**

14. ### Что такое флаг компиляции -fPIC?

**Флаг -fPIC** - это компиляция позиционно-независимого кода. Только из таких кодов можно сделать
динамическую библиотеку с разделяемыми кодами. Если компилировать модули без -fPIC и потом собрать
*.so, то формально динамическая библиотека получится, но код будет не разделяемым. Для каждого
процесса, использующего этот модуль, будет создаваться копия кодов. Флаг -fPIC нужен для компиляции из
исходника в объектник, для линковки не нужен. "Нормальный" процесс выглядит так:

```commandline
gcc t1.c -c -fPIC
gcc t2.c -c -fPIC
gcc t3.c -c -fPIC
gcc -shared t1.o t2.o t2.o -o libqqq.so
```

**[⬆ Back to Top](#table-of-contents)**

15. ### В чем разница между дебаженной и релизной сборкой?

**Конфигурация сборки** — это набор настроек проекта, которые определяют принцип его построения. Конфигурация
сборки состоит из:

-   имени исполняемого файла;

-   имени директории исполняемого файла;

-   имён директорий, в которых IDE будет искать другой код и файлы библиотек;

-   информации об отладке и параметрах оптимизации вашего проекта.

**Конфигурация Debug** предназначена для отладки программы. Эта конфигурация отключает все настройки по
оптимизации, включает информацию об отладке, что делает программы больше и медленнее, но упрощает
проведение отладки. Режим ```Debug``` обычно используется в качестве конфигурации по умолчанию.

**Конфигурация Release** используется во время сборки программы для её дальнейшего выпуска. Программа
оптимизируется по размеру и производительности и не содержит дополнительную информацию об отладке.

**[⬆ Back to Top](#table-of-contents)**

16. ### Что такое internal linkage?

**Единица трансляции** — минимальный блок исходного текста, который физически можно оттранслировать
(преобразовать во внутреннее машинное представление; в частности, откомпилировать).
В языках программирования Си и Си++ единица трансляции — подаваемый на вход компилятора исходный текст
(файл с расширением ```.c``` или ```.cpp```) со всеми включёнными в него файлами.

**Internal linkage** — свойство объекта или функции. Если объект или функция имеют ```internal linkage```
то эта самая функция или объект видны линкеру только внутри своей еденицы трансляции. За это отвечает
ключевое слово ```static```.

**External linkage** — так же свойство объекта или функции, но он оповещает линкер, что объект или функция
должны быть видны вне своей еденицы трансляции. За это отвечает ключевое слово ```extern```.

Дефолтные настройки компилятора в плане связки (linkage):

-   Неконстантные глобальные переменные имеют  ```external linkage```.

-   Константные глобальные переменные имеют  ```Internal linkage```.

-   Функции имеют ```external linkage``` изначально.


**[⬆ Back to Top](#table-of-contents)**

17. ### Что такое барьеры памяти?

**Барьер памяти** — вид барьерной инструкции, которая приказывает компилятору (при генерации инструкций) и
центральному процессору (при исполнении инструкций) устанавливать строгую последовательность между
обращениями к памяти (переменные в этой памяти и т.д.) до и после барьера. Это означает, что все обращения
к памяти перед барьером будут гарантированно выполнены до первого обращения к памяти после барьера.

Барьеры памяти работают только на аппаратном уровне. Компиляторы могут также переупорядочить инструкции как
часть оптимизации программы. Меры по предотвращению переупорядочивания необходимы только для данных, которые
не защищены примитивами синхронизации.

В языках ```С``` и ```С++``` ключевое слово ```volatile``` предназначено для исключения оптимизаций
компилятора. Используется чаще всего для работы с отображаемым в память вводом-выводом. Однако данное
ключевое слово никак не обеспечивает атомарность и защиту от внеочередного исполнения.

**[⬆ Back to Top](#table-of-contents)**

### C


18. ### В каких случаях используется ключевое слово ```static```?

в языке Си используется
в трёх случаях:

-   Переменная, описанная внутри тела функции как статическая, сохраняет свое значение между
    вызовами функции.

-   Переменная, описанная как статическая внутри модуля, но снаружи тела функции, доступна для
    всех функций в пределах этого модуля и не доступна функциям любых других модулей. То есть,
    это локализованная глобальная переменная.

-   Статический объект класса, создается на старте и уничтожается при завершении программы, и
    инициализируется только один раз. Инициализация объекта происходит, как и обычно — через
    конструктор класса.

-   Статическое поле класса, будет одним для всех экземпляров этого класса.

-   Статические методы класса, можно использовать без создания объекта класса. Доступ к статическим
    функциям осуществляется с использованием имени класса и *оператора разрешения области видимости (::)*
    Внутри функции обращаться можно только к статическим членам данных, другим статическим функциям-членам
    и любым другим функциям извне класса. Статические функции-члены имеют область видимости класса, в
    котором они находятся. Вы не имеете доступа к указателю ```this``` класса, потому что мы не создаем
    никакого объекта для вызова этой функции.

-   Функции, описанные внутри модуля как статические, могут быть вызваны только другими функциями
    из этого модуля. То есть, область видимости функции локализована модулем, внутри которого она
    описана.


**[⬆ Back to Top](#table-of-contents)**

19. ### Что означает ключевое слово ```const```?

```const``` означает - «только для чтения».

Что означают следующие объявления?

```cpp
const int a;

int const a;

const int *a;

int * const a;

const int * const a;
```

-   Первые два объявления означают одну и ту же вещь, а именно: «а» - это целочисленная
    константа (только для чтения).

-   Третье означает, что «а» является указателем на целочисленную константу.

-   Четвёртое описывает «а» как константный указатель на целое.

-   И последнее объявление — константный указатель на целочисленную константу.

Важность ```const```:

-   Использование спецификатора ```const``` сообщает полезную информацию тому, кто читает код.
    Фактически, объявление параметра как ```const```, говорит пользователю о его предполагаемом
    использовании.

-   ```сonst``` сообщает оптимизатору некоторую дополнительную информацию, что потенциально
    позволяет генерировать более оптимальный код.

-   Код, в котором используется спецификатор ```const```, проявляет тенденцию к меньшему количеству
    ошибок.

**[⬆ Back to Top](#table-of-contents)**

20. ### Что означает ключевое слово ```extern```?

В дополнение к области видимости и продолжительности жизни, переменные имеют еще одно свойство —
связь. Связь переменной определяет, относятся ли несколько упоминаний одного идентификатора к одной и
той же переменной или нет.

Переменная без связей — это переменная с локальной областью видимости, которая относится только к блоку,
в котором она определена. Это обычные локальные переменные. Две переменные с одинаковыми именами, но
определенные в разных функциях, не имеют никакой связи — каждая из них считается независимой единицей.

Переменная, имеющая внутренние связи, называется внутренней переменной (или «статической переменной»).
Она может использоваться в любом месте файла, в котором определена, но не относится к чему-либо вне этого
файла.

Переменная, имеющая внешние связи, называется внешней переменной. Она может использоваться как в файле, в
котором определена, так и в других файлах.

Если вы хотите сделать глобальную переменную внешней (которую можно использовать в любом файле программы)
— используйте ключевое слово ```extern```.

**[⬆ Back to Top](#table-of-contents)**

21. ### Что означает ключевое слово ```volatile```?

Ключевое слово ```volatile``` информирует компилятор о том, что переменная может быть изменена не только из
текущего выполняемого кода, но и из других мест. Тогда компилятор будет избегать определенных оптимизаций этой
переменной.

Примеры ```volatile``` переменных:

-   Регистры в периферийных устройствах (например, регистры состояния)

-   Глобальные переменные, используемые в обработчиках прерываний.

-   Глобальные переменные, используемые совместно несколькими задачами в многопотоковом приложении.

**[⬆ Back to Top](#table-of-contents)**

22. ### Какие есть битовые операции?

В языке С++ есть 6 побитовых операторов:

|Оператор | Символ | Пример | Операция |
|  :---:  | :----: | :----: | :------: |
| Побитовый сдвиг влево | ```<<``` | ```x << y``` | Все биты в ```x``` смещаются влево на ```y``` бит |
| Побитовый сдвиг вправо | ```>>``` | ```x >> y``` | Все биты в ```x``` смещаются вправо на ```y``` бит |
| Побитовое НЕ | ```~``` | ```~x``` | Все биты в ```x``` меняются на противоположные |
| Побитовое И | ```&``` | ```x & y``` | Каждый бит в ```x``` И каждый соответствующий ему бит в ```y``` |
| Побитовое ИЛИ | ```|``` | ```x | y``` | Каждый бит в ```x``` ИЛИ каждый соответствующий ему бит в ```y``` |
| Побитовое исключающее ИЛИ (XOR)| ```^``` | ```x ^ y```| Каждый бит в ```x``` XOR с каждым соответствующим ему битом в ```y``` |

**[⬆ Back to Top](#table-of-contents)**

23. ### Где хранятся переменные в памяти?

Переменные сохраняются:

-    в стеке, если они ```automatic function-local variables```

-    в куче, если они выделены с помощью ```new``` или ```malloc``` и т.д.

-    в области данных каждого процесса, если они глобальны или ```static```.

Все это хранится в ОЗУ. Компиляторы могут оптимизировать код для хранения переменных в регистрах,
но это не желательно.

**[⬆ Back to Top](#table-of-contents)**
