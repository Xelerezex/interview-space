# Questions for pure C interview

### Вопрос 01: В приведенной программе есть проблема. Можете её найти?

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char buff[10];
    memset(buff, 0, sizeof(buff));

    gets(buff);

    printf("\n The buffer entered is [%s]\n",buff);

    return 0;
}
```
#### Output:
```commandline
[-Wimplicit-function-declaration]
    9 |     gets(buff);
      |     ^~~~
      |     fgets
/usr/bin/ld: /tmp/ccXRxSAf.o: в функции «main»:
01.c:(.text+0x3e): предупреждение: the `gets' function is dangerous and should not be used.
```

#### Ответ:
Скрытая проблема в этом коде – это использование функции ```gets()```. Эта функция принимает строку со
стандартного ввода без проверки размера буфера, в который будет помещена эта строка. Это запросто может
привести к переполнению буфера. В данном случае лучше использовать другую стандартную функцию – ```fgets()```.


### Вопрос 02: Приведенный код реализует простейшую защиту по паролю. Можно ли вы взломать эту защиту, не зная пароля?

```c
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[])
{
    int flag = 0;
    char passwd[10];

    memset(passwd,0,sizeof(passwd));

    strcpy(passwd, argv[1]);

    if(0 == strcmp("LinuxGeek", passwd))
    {
        flag = 1;
    }

    if(flag)
    {
        printf("\n Password cracked \n");
    }
    else
    {
        printf("\n Incorrect passwd \n");

    }
    return 0;
}
```

#### Output:
```commandline
/home/person/Документы/interview/pure-c-questions/02.c:12:13: warning: implicit declaration of function
‘strcmp’ [-Wimplicit-function-declaration]
   12 |     if(0 == strcmp("LinuxGeek", passwd))
      |             ^~~~~~
[Finished in 229ms with exit code -11]
```

#### Ответ:
Да. Логику кода аутентификации, приведенного выше, можно обойти при помощи уязвимости в функции ```strcpy()```.
Эта функция копирует пароль, предоставленный пользователем, в буфер ```passwd```, не проверяя, достаточно ли в
этом буфере места. Предположим, что пользователь введет случайный пароль, имеющий длину достаточную для того,
чтобы заполнить как буфер ```passwd```, так и перезаписать область памяти, содержащую изначальное значение ```0```
переменной ```flag```. В этом случае, даже если сравнение введенной строки и пароля не пройдет, то все равно
проверка флага, который изначально имел нулевое значение, станет ненулевым, и таким образом, защита будет
“взломана”.

К примеру:

```commandline
$ ./psswd aaaaaaaaaaaaa

Password cracked
```

Здесь можно видеть, что хотя введенный пароль был некорректен, но программа все равно была взломана через
ошибку переполнения буфера.

Для защиты от подобных случаев следует пользоваться функцией ```strncpy()```.

Замечание от автора: В наши дни компиляторы стали довольно умными – они автоматически отлавливают подобные
случаи и располагают переменные на стеке таким образом, чтобы значительно усложнить взлом стека. В моем
случае, компилятор ```gcc``` включил эту опцию по умолчанию, и поэтому мне пришлось воспользоваться обратной
опцией ```-fno-stack-protector```, чтобы воспроизвести традиционное поведение компилятора.

### Вопрос 03: Скомпилируется ли следующий код? Если да, то какие проблемы могут возникнуть?

```c
#include <stdio.h>

void main(void)
{
    char *ptr = (char*)malloc(10);

    if(NULL == ptr)
    {
        printf("\n Malloc failed \n");
        return;
    }
    else
    {
        // Do some processing
        free(ptr);
    }

    return;
}
```

#### Ответ:
Этот код скомпилируется без ошибок, но с варнингом (на большинстве компиляторов) о том, что
значение, возвращаемое функцией ```main()```, должно иметь тип ```int```, а не ```void```. Тип ```int```
позволяет программам возвращать код статуса, что очень важно, когда программа выполняется как часть скрипта,
и внутри скрипта есть условия, которые зависят от результата выполнения программы.

### Вопрос 04: Приведет ли следующий код к утечкам памяти?

```c
#include <stdio.h>

void main(void)
{
    char *ptr = (char*)malloc(10);

    if(NULL == ptr)
    {
        printf("\n Malloc failed \n");
        return;
    }
    else
    {
        // Do some processing
    }

    return;
}
```

```commandline
[Finished in 49ms with exit code 160] <- Finished with error
```

#### Ответ:
Конечно, этот код не освобождает память после ее выделения, но это не приведет к утечке памяти, ведь
программа завершается почти сразу же. Операционная система автоматически очищает всю задействованную
программой память, при ее завершении. Однако, если вышеприведенный код будет находиться в цикле вроде
```while```, это приведет к серьезным утечкам памяти.

### Вопрос:
Следующая программа вылетает с ошибкой сегментации, если ввести ‘freeze’. Однако если ввести ‘zebra’, то все
будет хорошо. Почему?

```c
#include <stdio.h>

int main(int argc, char *argv[])
{
    char *ptr = (char*)malloc(10);

    if(NULL == ptr)
    {
        printf("\n Malloc failed \n");
        return -1;
    }
    else if(argc == 1)
    {
        printf("\n Usage  \n");
    }
    else
    {
        memset(ptr, 0, 10);

        strncpy(ptr, argv[1], 9);

        while(*ptr != 'z')
        {
            if(*ptr == '\0')
                break;
            else
                ptr++;
        }

        if(*ptr == 'z')
        {
            printf("\n String contains 'z'\n");
            // Do some more processing
        }

       free(ptr);
    }

    return 0;
}
```


#### Ответ:

Здесь проблема заключается в том, что код изменяет адрес указателя ```ptr``` (путем инкремента переменной
```ptr```) внутри цикла ```while```. Когда пользователь вводит ```zebra```, цикл ```while``` завершается
без единой итерации, поэтому адрес, переданный функции ```free()```, будет точно такой же, какой был
присвоен функцией ```malloc()```. Однако в случае с ```freeze```, значение переменной ```ptr``` изменяется
внутри цикла ```while```, что приводит к передаче неправильного адреса в функцию ```free``` и ошибке сегментации.


### Вопрос 06:
В следующем коде функция func() не вызывается. Почему?

```c
#include <stdio.h>

void func(void)
{
    printf("\n Cleanup function called \n");
    return;
}

int main(void)
{
    int i = 0;

    atexit(func);

    for(;i<0xffffff;i++);

    _exit(0);
}
```

#### Ответ:
Из-за функции ```_exit()```. Эта функция не вызывает функции очистки вроде ```atexit()```. Если нужно, чтобы
функции ```atexit()``` все-таки вызывались, нужно воспользоваться ```exit()``` или ключевым словом ```return```.

### Вопрос 07:
Напишите функцию, которая принимает аргумент любого типа, а возвращает ```int```. И еще, можно ли будет передать
ей более чем один аргумент?

#### Ответ:
Функция, которая принимает аргумент любого типа, выглядит так:

```c
    int func(void *ptr)
```

Если нужно передать более одного аргумента, тогда этой функции нужно передавать в качестве аргумента - указатель
на структуру, а в полях структуры - аргументы, которые нужно передать.

### Вопрос 08:
Что напечатает данная программа и почему?

```c
#include <stdio.h>

int main(void)
{
    char *ptr = "Linux";
    printf("\n [%c] \n",*ptr++);
    printf("\n [%c] \n",*ptr);

    return 0;
}
```

#### Ответ: Программа выведет следующее:

```commandline
[L]
[i]
```
Так как приоритет операторов ```++``` и ```*``` одинаков, то обработка ```*ptr++``` будет осуществляться справа
налево. Следуя этой логике, сначала вычисляется ```ptr++```, а затем ```*ptr```. Таким образом, получаем
```L```. Так как к ```ptr``` был применен постфиксный оператор ```++```, второй ```printf()``` напечатает ```i```.


### Вопрос 09:
Следующий код завершается с ошибкой сегментации. Объясните, почему?

```c
#include <stdio.h>

int main(void)
{
    char *ptr = "Linux";
    *ptr = 'T';

    printf("\n [%s] \n", ptr);

    return 0;
}
```

#### Ответ:
Потому что операция ```*ptr = 'T'``` пытается изменить первый байт строки ```Linux```, которая хранится в памяти
в сегменте кода (а этот сегмент только для чтения). Эта операция некорректна, и приводит к падению программы с
ошибкой сегментации.

### Вопрос 10:
Напишите программу, которая изменяет свое имя во время выполнения.

#### Ответ: Например, такая:

```c
#include <stdio.h>

int main(int argc, char *argv[])
{
    int i = 0;
    char buff[100];

    memset(buff, 0, sizeof(buff));

    strncpy(buff, argv[0], sizeof(buff));
    memset(argv[0], 0, strlen(buff));

    strncpy(argv[0], "NewName", 7);

    // Simulate a wait. Check the process
    // name at this point.
    for(;i<0xffffffff;i++);

    return 0;
}
```

### Вопрос 11:
Есть ли проблемы с данным кодом? Если да, то как от них можно избавиться?

```c
#include <stdio.h>

int* inc(int val)
{
  int a = val;
  a++;
  return &a;
}

int main(void)
{
    int a = 10;

    int *val = inc(a);

    printf("\n Incremented value is equal to [%d] \n", *val);

    return 0;
}
```

#### Ответ:
Хотя эта программа может отрабатывать нормально, однако у нее есть серьезная ошибка в функции ```inc()```.
Эта функция возвращает адрес локальной переменной. Время жизни этой локальной переменной - это время,
пока выполняется функция ```inc()```. После того, как функция ```inc()``` отработала, использование адреса
локальной переменной может приводить к непредсказуемым результатам. Эту программу можно исправить, если
передавать в функцию ```inc()``` не значение переменной ```a```, а ее адрес. Таким образом, мы будем вносить
изменения только по этому адресу, и не будем задействовать локальные адреса переменных.

### Вопрос12:
Что выведет следующий код?

```c
#include <stdio.h>

int main(void)
{
    int a = 10, b = 20, c = 30;

    printf("\n %d..%d..%d \n", a+b+c, (b = b*2), (c = c*2));

    return 0;
}
```

#### Ответ: Программа выведет следующее:

```commandline
110..40..60
```

Несмотря на то, что аргументы функции printf отображаются слева направо, но обрабатываются справа налево.


### Вопрос 13:
Используя директиву ```#define```, как бы вы описали именованную константу, которая возвращает
число секунд в году? Високосными годами следует пренебречь.

#### Ответ:

```c
#define SECONDS_PER_YEAR (60UL * 60UL * 24UL * 365UL)
```

Здесь я смотрю на несколько моментов:

-   Базовое знание синтаксиса ```#define``` (т.е. отсутствие точки с запятой в конце,
    необходимость заключать в круглые скобки и т.д.).

-   Правильный выбор имени - с применением заглавных букв и подчёркиванием.

-   Понимание того, что препроцессор будет вычислять для вас константное выражение.

-   Понимание того, что выражение переполнит ```integer``` аргумент на 16-и битной машине -
    а следовательно потребность в ```L```, указывающей компилятору обращаться с выражением
    как с ```Long```.

-   А если вы в добавок написали выражение с ```UL``` (обозначающее ```unsigned long```),
    то вы отлично начали тест, потому что показываете, что знаете об опасности типов со
    знаками и без, и запомните - первое впечатление считается!

### Вопрос 14:
Напишите «стандартный» макрос ```MIN```. То есть, макрос, который берет два аргумента и
возвращает меньший из них.

#### Ответ:

```cpp
#define MIN(A, B)       ((A) <= (B) ? (A) : (B))
```

Цель этого вопроса - проверить следующее:

-   Умение использовать директиву ```#define``` для написания макросов. Это важно, потому что до
    того, как ```inline``` оператор стал частью Си стандарта, макросы были единственным способом
    генерирования встраиваемого кода. А такой код часто бывает необходим для достижения требуемого
    уровня производительности.

-   Знание троичного условного оператора. Он используется в Си, потому что позволяет компилятору
    производить потенциально более оптимальный код, чем последовательность ```if-else```.
    Производительность обычно является важной составляющей  во встраиваемых  системах, поэтому
    необходимо знать и уметь использовать эту конструкцию.

-   Понимание необходимости заключать аргументы макросов в скобки.

-   Я также использую этот вопрос, чтобы начать разговор о побочных эффектах макросов.
    Например, о том, что происходит, когда вы пишите такой код: ```least = MIN(*p++, b);```

### Вопрос 15:
Каково назначение директивы препроцессора #error?

#### Ответ:

Этот вопрос очень полезен, если требуется отличить нормальных парней от ботаников. Обычно
только ботаники читают приложения к руководствам по Си, чтобы узнать о таких вещах.

### Вопрос 16:
При программировании встраиваемых систем часто используются бесконечные циклы. Как реализовать
бесконечный цикл в Си?

#### Ответ:

Существует несколько решений этой проблемы. Я предпочитаю такое:

```c
while(1)
{
   …
}
```

Другая общепринятая конструкция выглядит так:

```c
for( ; ; )
{
   …
}
```

Лично я не люблю эту конструкцию, потому что такой синтаксис не объясняет, что происходит.
Если кандидат предлагает именно это решение, я пытаюсь выяснить, чем он обосновывает свои действия.
Если ответ сводится к тому, что - «Меня научили так делать, и я никогда об этом с тех пор не
думал» - это говорит не в пользу кандидата. С другой стороны, если он заявляет, что Керниган и
Ритчи предпочитали этот метод, и это единственный способ для бесконечного цикла пройти контроль
на соответствие стандартам, то он получает дополнительные очки.

Третье решение заключается в использовании goto:

```c
Loop:
…
goto Loop;
```

Кандидаты, которые предлагают этот вариант, являются либо программистами на языке ассемблера,
либо они оторванные от жизни программисты Бейсика/Фортрана, ищущие новое поле для деятельности.

### Вопрос 17:
Используя переменную «a», запишите объявления для:

-   Целого
-   Указателя на целое
-   Указателя на указатель на целое
-   Массива из десяти целых
-   Массива из десяти указателей на целые
-   Указателя на массив из десяти целых
-   Указателя на функцию, которая принимает целочисленный аргумент и возвращает целое
-   Массива из десяти указателей на функции, которая принимает целочисленный аргумент и
    возвращает целое

#### Ответ:

```c
int a;             // Целое

int *a;            // Указатель на целое

int **a;           // Указатель на указатель на целое

int a[10];         // Массив из десяти целых

int *a[10];        // Массив из десяти указателей на целые

int (*a)[10];      // Указатель на массив из десяти целых

int (*a)(int);     // Указатель на функцию, которая берет целый аргумент и возвращает целое

int (*a[10])(int); // Массив из десяти указателей на функции, которые берут целый аргумент и возвращают целое
```

Люди часто утверждают, что на некоторые из этих вопросов они обычно ищут ответы  в  руководствах –
согласен. Во время написания этой статьи я сверялся с руководствами, чтобы убедиться, что
синтаксис является верным. Однако во время своего интервью я обычно ожидаю, что мне зададут
подобный вопрос. Поэтому я должен быть уверен, что у меня есть ответы, по крайней мере, на
несколько часов интервью. Кандидаты, которые не знают ответов (или, по крайней мере, большую
их часть), просто не готовы к интервью. Если они не могут быть готовы к интервью, к чему они
могут быть готовы вообще?

### Вопрос 18:

В каких случаях используется ключевое слово static?

#### Ответ:

Полностью отвечают на этот вопрос довольно редко. Спецификатор ```static``` в языке Си используется
в трёх случаях:

-   Переменная, описанная внутри тела функции как статическая, сохраняет свое значение между
    вызовами функции.

-   Переменная, описанная как статическая внутри модуля, но снаружи тела функции, доступна для
    всех функций в пределах этого модуля и не доступна функциям любых других модулей. То есть,
    это локализованная глобальная переменная.

-   Функции, описанные внутри модуля как статические, могут быть вызваны только другими функциями
    из этого модуля. То есть, область видимости функции локализована модулем, внутри которого она
    описана.

Большинство кандидатов отвечают правильно на первую часть. Умеренное число кандидатов справляется
со второй частью, ну и небольшое количество понимают ответ (с). Это серьёзный недостаток кандидата,
если он не понимает важность и преимущества ограничения области видимости данных и кода.


### Вопрос 18:
Что означает ключевое слово ```const```?

#### Ответ:

Как только интервьюируемый говорит: «Const - значит константа», я понимаю, что имею дело с
непрофессионалом. Дэн Сакс в прошлом году дал исчерпывающее объяснение спецификатору const,
так что каждый читатель ```ESP``` должен быть досконально ознакомлен с тем, что ```const```
может сделать для вас и чего он не может. Если вы не читали эту рубрику, достаточно будет
сказать, что const означает «только для чтения». Хотя этот ответ не совсем справедливо
отражает предмет разговора, я бы принял его в качестве правильного.

Если кандидат даст правильный ответ, то я задам ему следующие дополнительные вопросы:

Что означают следующие объявления?

```c
const int a;

int const a;

const int *a;

int * const a;

const int * const a;
```

-   Первые два объявления означают одну и ту же вещь, а именно: «а» - это целочисленная
    константа (только для чтения).

-   Третье означает, что «а» является указателем на целочисленную константу.

-   Четвёртое описывает «а» как константный указатель на целое.

-   И последнее объявление — константный указатель на целочисленную константу.

Если кандидат правильно ответит на эти вопросы, я буду впечатлён.
В данном случае он может поинтересоваться, почему я делаю такой упор на спецификатор ```const```,
так как очень легко написать правильно функционирующую программу, не используя его ни разу.
Существует несколько причин:

-   Использование спецификатора ```const``` сообщает полезную информацию тому, кто читает ваш код.
    Фактически, объявление параметра как ```const```, говорит пользователю о его предполагаемом
    использовании. Если вы когда-нибудь тратили много времени, устраняя неразбериху, оставленную
    другими людьми, то вы быстро научитесь ценить эту дополнительную информацию. (Конечно,
    программисты, использующие ```const```, редко оставляют после себя путаницу, которую
    приходится устранять другим…)

-   ```Const``` сообщает оптимизатору некоторую дополнительную информацию, что потенциально
    позволяет генерировать более оптимальный код.

-   Код, в котором используется спецификатор ```const```, проявляет тенденцию к меньшему количеству
    ошибок.

### Вопрос 19:
Что означает ключевое слово ```volatile```? Приведите три различных примера его использования.

#### Ответ:

Ключевое слово ```volatile``` информирует компилятор о том, что переменная может быть изменена не только из
текущего выполняемого кода, но и из других мест. Тогда компилятор будет избегать определенных оптимизаций этой
переменной.

Примеры volatile переменных:

-   Регистры в периферийных устройствах (например, регистры состояния)

-   Глобальные переменные, используемые в обработчиках прерываний.

-   Глобальные переменные, используемые совместно несколькими задачами в многопотоковом приложении.

#### Дополнительно:

Если кандидат не знает ответ на этот вопрос, он не получит работу. Я считаю, что это наиболее существенный вопрос,
который позволяет отличить «Си-программиста» от «программиста встраиваемых систем». Программисты встраиваемых
систем сталкиваются с аппаратными средствами, прерываниями, ОСРВ, и тому подобным. Все эти вещи требуют
использования volatile переменных. Непонимание идеи спецификатора volatile приведет к катастрофе.

Исходя из (сомнительного) предположения, что интервьюируемый ответит на этот вопрос правильно, я люблю копнуть
немного глубже, чтобы посмотреть, на самом ли деле он полностью понимает значение этого спецификатора. В частности,
я задам ему следующие вопросы:

-   Может ли аргумент быть одновременно и const и volatile? Аргументируйте ваш ответ.

-   Может ли указатель быть volatile? Аргументируйте ваш ответ.

-   Что не так со следующей функцией?:

```c
int square(volatile int *ptr)
{
   return *ptr * *ptr;
}
```

#### Ответ:

-   Да. Например, регистр состояния доступный только для чтения. Он volatile, потому что может меняться неожиданно.
    Он ```const```, потому что программа не должна пытаться изменить его.

-   Да. Хотя это не общепринятый случай. Например, когда обработчик прерываний изменяет указатель на буфер.

-   Эта функция потенциально опасна. Назначение кода состоит в возвращении квадрата значения, указанного при помощи
    ```*ptr```. Однако, поскольку ```*ptr``` указывает на ```volatile``` переменную, компилятор сгенерирует код,
    который выглядит примерно так:

```c
int square(volatile int *ptr)
{
    int a,b;
    a = *ptr;
    b = *ptr;
    return a * b;
}
```

Поскольку значение переменной на которую указывает ```ptr``` может неожиданно измениться, то существует
возможность,  что ```а``` и ```b``` будут разными. Следовательно, этот код может возвратить число, которое
не будет квадратом! Правильный вариант кода в данном случае такой:

```c
int square(volatile int *ptr)
{
   int a;
   a = *ptr;
   return a * a;
}
```

### Вопрос 20:
При программировании встраиваемых систем приходится часто манипулировать битами в регистрах или переменных.
Дана целая переменная ```а```, напишите два фрагмента кода. Первый должен установить 3-ий бит этой переменной.
Второй должен очищать его. В обоих случаях, другие биты должны остаться без изменений.

#### Ответ:

Вот три наиболее распространённых ответа на этот вопрос:

-   Никаких идей. Кандидат никоим образом не может работать со встраиваемыми системами.

-   Используйте битовые поля. Битовые поля покинули этот мир, наряду с триграфами, как самая бестолковая часть
    языка Си. Битовые поля по своей природе не переносимы между компиляторами, и по существу гарантируют, что
    ваш код не допускает многократного использования. Недавно я имел несчастье взглянуть на драйвер, который
    написали в ```Infineon``` для одного из их наиболее сложных коммуникационных чипов. Там  использовались
    битовые поля, и драйвер был полностью бесполезен, потому что мой компилятор выполнял битовые поля другим
    путём. Мораль – никогда не позволяйте программисту, не знакомому со встраиваемыми системами, подходить к
    реальному оборудованию.

Я недавно смягчил свою позицию по битовым полям. По меньшей мере один производитель компиляторов (IAR) теперь
предлагает ключ компилятора для определения расположения битовых полей. К тому же их компилятор генерирует
оптимальный код с регистрами описанными как битовые поля, и по существу - теперь я использую битовые поля в
IAR-приложениях.

-   Используйте #define и битовые маски. Это хорошо переносимый метод и его стоит использовать. Оптимальное
    решение этой проблемы, на мой взгляд, было бы таким:

```c
#define BIT3       (0?1 << 3)

static int a;

void set_bit3(void)
{
   a |= BIT3;
}

void clear_bit3(void)
{
   a &= ~BIT3;
}
```

Некоторые люди, наряду с именованными константами, предпочитают задавать маску для значений set и clear. Это
тоже приемлемо. Важные элементы, которые мне нужны – это использование именованных констант, наряду с
конструкциями |= и &= ~


### Вопрос 21:
Довольно часто программистам встраиваемых систем требуется доступ к определенной ячейке памяти. В некотором
проекте требуется установить целую переменную по абсолютному адресу  0?67a9 к значению 0xaa55. Напишите код,
выполняющий эту задачу.

#### Ответ:
Цель данной задачи выяснить, знаете ли Вы, что разрешено приведение целочисленных типов к указателю, чтобы
получить доступ по абсолютному адресу. Правильный синтаксис может варьироваться в зависимости от стиля. Однако
обычно я хочу увидеть что-то вроде этого:

```c
int *ptr;
ptr = (int *)0?67a9;
*ptr = 0xaa55;
```

Более запутывающий вариант выглядит так:

*(int * const)(0?67a9) = 0xaa55;

### Вопрос 22:
Прерывания являются важной частью встраиваемых систем. Поэтому многие производители компиляторов предлагают к
стандартному языку Си расширение для поддержки прерываний. Обычно - это новое ключевое слово ```__interrupt```.
Следующий код использует ```__interrupt```, чтобы описать программу обработки прерываний. Прокомментируйте его.

#### Ответ:

```c
__interrupt double compute_area(double radius)
{
   double area = PI * radius * radius;
   printf(“\nArea = %f”, area);
   return area;
}
```

В этой функции так много неправильного, что почти невозможно понять с чего начинать.

-   Обработчик прерываний не может возвращать значение. Если вы не понимаете этого, то не получите работу.

-   Обработчик прерываний не может принимать параметры. Если вы упустили это, смотрите пункт (а) для понимания
    ваших перспектив получить работу.

-   Во многих процессорах/компиляторах, операции с плавающей точкой не обязательно реентерабельны. В некоторых
    случаях они нуждаются в добавлении в стек дополнительных регистров, в других случаях, они просто не могут
    выполнить эти операции в обработчике прерываний. Более того, при условии главного практического требования,
    что обработчики прерываний должны быть короткими и ясными, возникает вопрос об уместности выполнения здесь
    подобной математики.

-   Функция ```printf()``` тоже часто испытывает трудности с реентерабельностью и работоспособностью. Если бы
    вы пропустили пункты (с) и (d), то я не был бы с вами слишком строг. А если вы справились с этим двумя
    пунктами, то ваши перспективы получить работу выглядят всё лучше и лучше.

### Вопрос 23:
Что делает следующий фрагмент кода и почему?

```c
void foo(void)
{
   unsigned int a = 6;
   int b = -20;
   (a+b > 6) ? puts(“> 6?) : puts(“<= 6?);
}
```

#### Ответ:
Этот вопрос проверяет, разбираетесь ли вы в правилах представления целых чисел в Си, – области, которую я нахожу
очень плохо понимаемой многими разработчиками. Ответ состоит в том, что выведется “> 6”. Причина -  в выражениях,
включающих типы со знаком и без  все операнды приводятся к типам без знака. Таким образом, -20 становится очень
большим положительным целым, и выражение оценивается больше, чем 6. Это очень важный момент во встраиваемых
системах, где часто используются типы данных без знака. Если вы ответили на этот вопрос неправильно, то вы сильно
рискуете быть не принятым на работу.

### Вопрос 24:
Прокомментируйте следующий фрагмент кода:

```c
unsigned int zero = 0;
unsigned int compzero = 0xFFFF;       /*1’s complement of zero */
```

#### Ответ:

В машинах, где ```int``` не равен 16-и битам, это будет неправильно. Следует записать так:

```c
unsigned int compzero = ~0;
```

Этот вопрос даёт возможность по-настоящему узнать, понимает ли кандидат важность длины слова в компьютере.

На этой стадии кандидаты либо полностью деморализованы, либо они на коне и предаются приятному времяпровождению.
Если очевидно, что кандидат не очень хорош, то на этом тест заканчивается. Однако если кандидат отлично себя
проявил, то я задаю дополнительные вопросы. Эти вопросы сложные и я ожидаю, что только лучшие кандидаты
справятся с ними.

### Вопрос 25:
В чём заключаются проблемы с динамическим распределением памяти во встраиваемых системах?

#### Ответ:

Здесь я ожидаю, что пользователь упомянет фрагментацию памяти, проблемы сбора мусора и т.д. Эта тема была хорошо
описана в ESP, главным образом, Плогером. Его объяснения гораздо более проницательны, чем что-либо из того, что
я могу предложить здесь, поэтому прочтите старые номера! Убаюкав кандидата ощущением ложной безопасности, я
задаю такой интересный вопрос:

Что делает следующий фрагмент кода и почему?

```c
char *ptr;
if ((ptr = (char *)malloc(0)) == NULL) {
   puts(“Got a null pointer”);
}
else {
   puts(“Got a valid pointer”);
}
```

Это довольно забавная задачка. Я столкнулся с ней недавно, когда мой коллега ненароком передал значение ```0``` в
```malloc``` и получил назад действительный указатель! Покопавшись немного, я обнаружил, что результат функции
```malloc (0)``` определён реализацией, так что правильный ответ гласит «по обстоятельствам». Я использую этот
вопрос, чтобы начать беседу о том, что, по мнению интервьюируемого, является верным для действий функции
```malloc```. Получение правильного ответа здесь не важно, главное как вы подойдёте к проблеме и  логически
обоснуете свое решение.

### Вопрос 26:
Typedef часто используется в Си для объявления синонимов существующих типов данных. Также для подобных действий
возможно использование препроцессора. Например, рассмотрите следующий фрагмент кода:

```c
#define dPS  struct s *
typedef  struct s * tPS;
```

#### Ответ:
Цель в обоих случаях состоит в объявлении ```dPS``` и ```tPS``` как указателей на структуру ```s```. Какой метод
предпочтительней и почему?

Это очень хитрый вопрос, и всякий, кто ответит на него правильно, получит мои совершенно справедливые поздравления.
Ответ заключается в том, что предпочтителен ```typedef```. Рассмотрите объявления:

```c
dPS p1,p2;
tPS p3,p4;
```

Из первого примера следует:

```c
struct s * p1, p2;
```
что объявляет ```р1``` как указатель на структуру и ```р2``` как обычную структуру, что, вероятно, вовсе не то,
что вы хотели. Второй пример правильно определяет ```р3``` и ```р4``` как указатели.

### Вопрос 26:
Си позволяет некоторые ужасные конструкции. Допустима ли эта конструкция, и если да, то что делает этот код?

```c
int a = 5, b = 7, c;

c = a+++b;
```

#### Ответ:

Предполагается, что этот вопрос будет весёлым завершением опроса, в то время как, верите, или нет, это вполне
допустимый синтаксис. Вопрос в том, как компилятор его воспримет? Бедные авторы компиляторов обсуждали эту проблему
и пришли к правилу «максимального перемалывания», которое гласит, что компилятор должен «откусить» такой большой
(допустимый) кусок, какой только может. Следовательно, этот код будет восприниматься так:

```c
c = a++ + b;
```

Поэтому, после выполнения этого кода, ```a = 6, b = 7 & c = 12;```

Если вы знали ответ, или правильно угадали – тогда дело сделано. Если вы не знали ответа – не страшно. Я
нахожу наибольшую пользу от этой задачи в том, что она очень хорошо стимулирует вопросы относительно стилей
кодирования и преимуществ использования контроля стиля программирования на соответствие стандартам.
