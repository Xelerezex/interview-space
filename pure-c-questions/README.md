# Questions for pure C interview

### Вопрос 01: В приведенной программе есть проблема. Можете её найти?

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char buff[10];
    memset(buff, 0, sizeof(buff));

    gets(buff);

    printf("\n The buffer entered is [%s]\n",buff);

    return 0;
}
```
#### Output:
```commandline
[-Wimplicit-function-declaration]
    9 |     gets(buff);
      |     ^~~~
      |     fgets
/usr/bin/ld: /tmp/ccXRxSAf.o: в функции «main»:
01.c:(.text+0x3e): предупреждение: the `gets' function is dangerous and should not be used.
```

#### Ответ:
Скрытая проблема в этом коде – это использование функции ```gets()```. Эта функция принимает строку со
стандартного ввода без проверки размера буфера, в который будет помещена эта строка. Это запросто может
привести к переполнению буфера. В данном случае лучше использовать другую стандартную функцию – ```fgets()```.


### Вопрос 02: Приведенный код реализует простейшую защиту по паролю. Можно ли вы взломать эту защиту, не зная пароля?

```c
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[])
{
    int flag = 0;
    char passwd[10];

    memset(passwd,0,sizeof(passwd));

    strcpy(passwd, argv[1]);

    if(0 == strcmp("LinuxGeek", passwd))
    {
        flag = 1;
    }

    if(flag)
    {
        printf("\n Password cracked \n");
    }
    else
    {
        printf("\n Incorrect passwd \n");

    }
    return 0;
}
```

#### Output:
```commandline
/home/person/Документы/interview/pure-c-questions/02.c:12:13: warning: implicit declaration of function
‘strcmp’ [-Wimplicit-function-declaration]
   12 |     if(0 == strcmp("LinuxGeek", passwd))
      |             ^~~~~~
[Finished in 229ms with exit code -11]
```

#### Ответ:
Да. Логику кода аутентификации, приведенного выше, можно обойти при помощи уязвимости в функции ```strcpy()```.
Эта функция копирует пароль, предоставленный пользователем, в буфер ```passwd```, не проверяя, достаточно ли в
этом буфере места. Предположим, что пользователь введет случайный пароль, имеющий длину достаточную для того,
чтобы заполнить как буфер ```passwd```, так и перезаписать область памяти, содержащую изначальное значение ```0```
переменной ```flag```. В этом случае, даже если сравнение введенной строки и пароля не пройдет, то все равно
проверка флага, который изначально имел нулевое значение, станет ненулевым, и таким образом, защита будет
“взломана”.

К примеру:

```commandline
$ ./psswd aaaaaaaaaaaaa

Password cracked
```

Здесь можно видеть, что хотя введенный пароль был некорректен, но программа все равно была взломана через
ошибку переполнения буфера.

Для защиты от подобных случаев следует пользоваться функцией ```strncpy()```.

Замечание от автора: В наши дни компиляторы стали довольно умными – они автоматически отлавливают подобные
случаи и располагают переменные на стеке таким образом, чтобы значительно усложнить взлом стека. В моем
случае, компилятор ```gcc``` включил эту опцию по умолчанию, и поэтому мне пришлось воспользоваться обратной
опцией ```-fno-stack-protector```, чтобы воспроизвести традиционное поведение компилятора.

### Вопрос 03: Скомпилируется ли следующий код? Если да, то какие проблемы могут возникнуть?

```c
#include <stdio.h>

void main(void)
{
    char *ptr = (char*)malloc(10);

    if(NULL == ptr)
    {
        printf("\n Malloc failed \n");
        return;
    }
    else
    {
        // Do some processing
        free(ptr);
    }

    return;
}
```

#### Ответ:
Этот код скомпилируется без ошибок, но с варнингом (на большинстве компиляторов) о том, что
значение, возвращаемое функцией ```main()```, должно иметь тип ```int```, а не ```void```. Тип ```int```
позволяет программам возвращать код статуса, что очень важно, когда программа выполняется как часть скрипта,
и внутри скрипта есть условия, которые зависят от результата выполнения программы.

### Вопрос 04: Приведет ли следующий код к утечкам памяти?

```c
#include <stdio.h>

void main(void)
{
    char *ptr = (char*)malloc(10);

    if(NULL == ptr)
    {
        printf("\n Malloc failed \n");
        return;
    }
    else
    {
        // Do some processing
    }

    return;
}
```

```commandline
[Finished in 49ms with exit code 160] <- Finished with error
```

#### Ответ:
Конечно, этот код не освобождает память после ее выделения, но это не приведет к утечке памяти, ведь
программа завершается почти сразу же. Операционная система автоматически очищает всю задействованную
программой память, при ее завершении. Однако, если вышеприведенный код будет находиться в цикле вроде
```while```, это приведет к серьезным утечкам памяти.

### Вопрос:
Следующая программа вылетает с ошибкой сегментации, если ввести ‘freeze’. Однако если ввести ‘zebra’, то все
будет хорошо. Почему?

```c
#include <stdio.h>

int main(int argc, char *argv[])
{
    char *ptr = (char*)malloc(10);

    if(NULL == ptr)
    {
        printf("\n Malloc failed \n");
        return -1;
    }
    else if(argc == 1)
    {
        printf("\n Usage  \n");
    }
    else
    {
        memset(ptr, 0, 10);

        strncpy(ptr, argv[1], 9);

        while(*ptr != 'z')
        {
            if(*ptr == '\0')
                break;
            else
                ptr++;
        }

        if(*ptr == 'z')
        {
            printf("\n String contains 'z'\n");
            // Do some more processing
        }

       free(ptr);
    }

    return 0;
}
```


#### Ответ:

Здесь проблема заключается в том, что код изменяет адрес указателя ```ptr``` (путем инкремента переменной
```ptr```) внутри цикла ```while```. Когда пользователь вводит ```zebra```, цикл ```while``` завершается
без единой итерации, поэтому адрес, переданный функции ```free()```, будет точно такой же, какой был
присвоен функцией ```malloc()```. Однако в случае с ```freeze```, значение переменной ```ptr``` изменяется
внутри цикла ```while```, что приводит к передаче неправильного адреса в функцию ```free``` и ошибке сегментации.


### Вопрос 06:
В следующем коде функция func() не вызывается. Почему?

```c
#include <stdio.h>

void func(void)
{
    printf("\n Cleanup function called \n");
    return;
}

int main(void)
{
    int i = 0;

    atexit(func);

    for(;i<0xffffff;i++);

    _exit(0);
}
```

#### Ответ:
Из-за функции ```_exit()```. Эта функция не вызывает функции очистки вроде ```atexit()```. Если нужно, чтобы
функции ```atexit()``` все-таки вызывались, нужно воспользоваться ```exit()``` или ключевым словом ```return```.

### Вопрос 07:
Напишите функцию, которая принимает аргумент любого типа, а возвращает ```int```. И еще, можно ли будет передать
ей более чем один аргумент?

#### Ответ:
Функция, которая принимает аргумент любого типа, выглядит так:

```c
    int func(void *ptr)
```

Если нужно передать более одного аргумента, тогда этой функции нужно передавать в качестве аргумента - указатель
на структуру, а в полях структуры - аргументы, которые нужно передать.

### Вопрос 08:
Что напечатает данная программа и почему?

```c
#include <stdio.h>

int main(void)
{
    char *ptr = "Linux";
    printf("\n [%c] \n",*ptr++);
    printf("\n [%c] \n",*ptr);

    return 0;
}
```

#### Ответ: Программа выведет следующее:

```commandline
[L]
[i]
```
Так как приоритет операторов ```++``` и ```*``` одинаков, то обработка ```*ptr++``` будет осуществляться справа
налево. Следуя этой логике, сначала вычисляется ```ptr++```, а затем ```*ptr```. Таким образом, получаем
```L```. Так как к ```ptr``` был применен постфиксный оператор ```++```, второй ```printf()``` напечатает ```i```.


### Вопрос:
Следующий код завершается с ошибкой сегментации. Объясните, почему?

```c
#include <stdio.h>

int main(void)
{
    char *ptr = "Linux";
    *ptr = 'T';

    printf("\n [%s] \n", ptr);

    return 0;
}
```

#### Ответ:
Потому что операция ```*ptr = 'T'``` пытается изменить первый байт строки ```Linux```, которая хранится в памяти
в сегменте кода (а этот сегмент только для чтения). Эта операция некорректна, и приводит к падению программы с
ошибкой сегментации.

### Вопрос 10:
Напишите программу, которая изменяет свое имя во время выполнения.

#### Ответ: Например, такая:

```c
#include <stdio.h>

int main(int argc, char *argv[])
{
    int i = 0;
    char buff[100];

    memset(buff, 0, sizeof(buff));

    strncpy(buff, argv[0], sizeof(buff));
    memset(argv[0], 0, strlen(buff));

    strncpy(argv[0], "NewName", 7);

    // Simulate a wait. Check the process
    // name at this point.
    for(;i<0xffffffff;i++);

    return 0;
}
```

### Вопрос 11:

Есть ли проблемы с данным кодом? Если да, то как от них можно избавиться?

```c
#include <stdio.h>

int* inc(int val)
{
  int a = val;
  a++;
  return &a;
}

int main(void)
{
    int a = 10;

    int *val = inc(a);

    printf("\n Incremented value is equal to [%d] \n", *val);

    return 0;
}
```

#### Ответ:
Хотя эта программа может отрабатывать нормально, однако у нее есть серьезная ошибка в функции ```inc()```.
Эта функция возвращает адрес локальной переменной. Время жизни этой локальной переменной - это время,
пока выполняется функция ```inc()```. После того, как функция ```inc()``` отработала, использование адреса
локальной переменной может приводить к непредсказуемым результатам. Эту программу можно исправить, если
передавать в функцию ```inc()``` не значение переменной ```a```, а ее адрес. Таким образом, мы будем вносить
изменения только по этому адресу, и не будем задействовать локальные адреса переменных.

### Вопрос12:

Что выведет следующий код?

```c
#include <stdio.h>

int main(void)
{
    int a = 10, b = 20, c = 30;

    printf("\n %d..%d..%d \n", a+b+c, (b = b*2), (c = c*2));

    return 0;
}
```

#### Ответ: Программа выведет следующее:

```commandline
110..40..60
```

Несмотря на то, что аргументы функции printf отображаются слева направо, но обрабатываются справа налево.


### Вопрос 13:

Используя директиву ```#define```, как бы вы описали именованную константу, которая возвращает
число секунд в году? Високосными годами следует пренебречь.

#### Ответ:

```c
#define SECONDS_PER_YEAR (60UL * 60UL * 24UL * 365UL)
```

Здесь я смотрю на несколько моментов:

-   Базовое знание синтаксиса ```#define``` (т.е. отсутствие точки с запятой в конце,
    необходимость заключать в круглые скобки и т.д.).

-   Правильный выбор имени - с применением заглавных букв и подчёркиванием.

-   Понимание того, что препроцессор будет вычислять для вас константное выражение.

-   Понимание того, что выражение переполнит ```integer``` аргумент на 16-и битной машине -
    а следовательно потребность в ```L```, указывающей компилятору обращаться с выражением
    как с ```Long```.

-   А если вы в добавок написали выражение с ```UL``` (обозначающее ```unsigned long```),
    то вы отлично начали тест, потому что показываете, что знаете об опасности типов со
    знаками и без, и запомните - первое впечатление считается!

### Вопрос 14:

Напишите «стандартный» макрос ```MIN```. То есть, макрос, который берет два аргумента и
возвращает меньший из них.

#### Ответ:

```cpp
#define MIN(A, B)       ((A) <= (B) ? (A) : (B))
```

Цель этого вопроса - проверить следующее:

-   Умение использовать директиву ```#define``` для написания макросов. Это важно, потому что до
    того, как ```inline``` оператор стал частью Си стандарта, макросы были единственным способом
    генерирования встраиваемого кода. А такой код часто бывает необходим для достижения требуемого
    уровня производительности.

-   Знание троичного условного оператора. Он используется в Си, потому что позволяет компилятору
    производить потенциально более оптимальный код, чем последовательность ```if-else```.
    Производительность обычно является важной составляющей  во встраиваемых  системах, поэтому
    необходимо знать и уметь использовать эту конструкцию.

-   Понимание необходимости заключать аргументы макросов в скобки.

-   Я также использую этот вопрос, чтобы начать разговор о побочных эффектах макросов.
    Например, о том, что происходит, когда вы пишите такой код: ```least = MIN(*p++, b);```

### Вопрос 15:

Каково назначение директивы препроцессора #error?

#### Ответ:

Этот вопрос очень полезен, если требуется отличить нормальных парней от ботаников. Обычно
только ботаники читают приложения к руководствам по Си, чтобы узнать о таких вещах.

### Вопрос 16:

При программировании встраиваемых систем часто используются бесконечные циклы. Как реализовать
бесконечный цикл в Си?

#### Ответ:

Существует несколько решений этой проблемы. Я предпочитаю такое:

```c
while(1)
{
   …
}
```

Другая общепринятая конструкция выглядит так:

```c
for( ; ; )
{
   …
}
```

Лично я не люблю эту конструкцию, потому что такой синтаксис не объясняет, что происходит.
Если кандидат предлагает именно это решение, я пытаюсь выяснить, чем он обосновывает свои действия.
Если ответ сводится к тому, что - «Меня научили так делать, и я никогда об этом с тех пор не
думал» - это говорит не в пользу кандидата. С другой стороны, если он заявляет, что Керниган и
Ритчи предпочитали этот метод, и это единственный способ для бесконечного цикла пройти контроль
на соответствие стандартам, то он получает дополнительные очки.

Третье решение заключается в использовании goto:

```c
Loop:
…
goto Loop;
```

Кандидаты, которые предлагают этот вариант, являются либо программистами на языке ассемблера,
либо они оторванные от жизни программисты Бейсика/Фортрана, ищущие новое поле для деятельности.

### Вопрос 17:

Используя переменную «a», запишите объявления для:

-   Целого
-   Указателя на целое
-   Указателя на указатель на целое
-   Массива из десяти целых
-   Массива из десяти указателей на целые
-   Указателя на массив из десяти целых
-   Указателя на функцию, которая принимает целочисленный аргумент и возвращает целое
-   Массива из десяти указателей на функции, которая принимает целочисленный аргумент и
    возвращает целое

#### Ответ:

```c
int a;             // Целое

int *a;            // Указатель на целое

int **a;           // Указатель на указатель на целое

int a[10];         // Массив из десяти целых

int *a[10];        // Массив из десяти указателей на целые

int (*a)[10];      // Указатель на массив из десяти целых

int (*a)(int);     // Указатель на функцию, которая берет целый аргумент и возвращает целое

int (*a[10])(int); // Массив из десяти указателей на функции, которые берут целый аргумент и возвращают целое
```

Люди часто утверждают, что на некоторые из этих вопросов они обычно ищут ответы  в  руководствах –
согласен. Во время написания этой статьи я сверялся с руководствами, чтобы убедиться, что
синтаксис является верным. Однако во время своего интервью я обычно ожидаю, что мне зададут
подобный вопрос. Поэтому я должен быть уверен, что у меня есть ответы, по крайней мере, на
несколько часов интервью. Кандидаты, которые не знают ответов (или, по крайней мере, большую
их часть), просто не готовы к интервью. Если они не могут быть готовы к интервью, к чему они
могут быть готовы вообще?

### Вопрос 18:

В каких случаях используется ключевое слово static?

#### Ответ:

Полностью отвечают на этот вопрос довольно редко. Спецификатор ```static``` в языке Си используется
в трёх случаях:

-   Переменная, описанная внутри тела функции как статическая, сохраняет свое значение между
    вызовами функции.

-   Переменная, описанная как статическая внутри модуля, но снаружи тела функции, доступна для
    всех функций в пределах этого модуля и не доступна функциям любых других модулей. То есть,
    это локализованная глобальная переменная.

-   Функции, описанные внутри модуля как статические, могут быть вызваны только другими функциями
    из этого модуля. То есть, область видимости функции локализована модулем, внутри которого она
    описана.

Большинство кандидатов отвечают правильно на первую часть. Умеренное число кандидатов справляется
со второй частью, ну и небольшое количество понимают ответ (с). Это серьёзный недостаток кандидата,
если он не понимает важность и преимущества ограничения области видимости данных и кода.


### Вопрос 18:

Что означает ключевое слово ```const```?

#### Ответ:
Как только интервьюируемый говорит: «Const - значит константа», я понимаю, что имею дело с
непрофессионалом. Дэн Сакс в прошлом году дал исчерпывающее объяснение спецификатору const,
так что каждый читатель ```ESP``` должен быть досконально ознакомлен с тем, что ```const```
может сделать для вас и чего он не может. Если вы не читали эту рубрику, достаточно будет
сказать, что const означает «только для чтения». Хотя этот ответ не совсем справедливо
отражает предмет разговора, я бы принял его в качестве правильного.

Если кандидат даст правильный ответ, то я задам ему следующие дополнительные вопросы:

Что означают следующие объявления?

```c
const int a;

int const a;

const int *a;

int * const a;

const int * const a;
```

-   Первые два объявления означают одну и ту же вещь, а именно: «а» - это целочисленная
    константа (только для чтения).

-   Третье означает, что «а» является указателем на целочисленную константу.

-   Четвёртое описывает «а» как константный указатель на целое.

-   И последнее объявление — константный указатель на целочисленную константу.

Если кандидат правильно ответит на эти вопросы, я буду впечатлён.
В данном случае он может поинтересоваться, почему я делаю такой упор на спецификатор ```const```,
так как очень легко написать правильно функционирующую программу, не используя его ни разу.
Существует несколько причин:

-   Использование спецификатора ```const``` сообщает полезную информацию тому, кто читает ваш код.
    Фактически, объявление параметра как ```const```, говорит пользователю о его предполагаемом
    использовании. Если вы когда-нибудь тратили много времени, устраняя неразбериху, оставленную
    другими людьми, то вы быстро научитесь ценить эту дополнительную информацию. (Конечно,
    программисты, использующие ```const```, редко оставляют после себя путаницу, которую
    приходится устранять другим…)

-   ```Const``` сообщает оптимизатору некоторую дополнительную информацию, что потенциально
    позволяет генерировать более оптимальный код.

-   Код, в котором используется спецификатор ```const```, проявляет тенденцию к меньшему количеству
    ошибок.

~~~~~ Question 8!
